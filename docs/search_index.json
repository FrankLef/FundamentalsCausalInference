[["index.html", "Study project: Fundamentals of Causal Inferences With R Study Project About", " Study project: Fundamentals of Causal Inferences With R François Lefebvre 2022-03-26 Study Project About This is a study project Brumback (2022). Many thanks to Babette Brumback for a great book to tackle the question of causality and its measurements The exercises and their suggested solutions are in a separate project. The companion package for this project is fciR and can be found at fciR. References "],["intro.html", "Chapter 1 Introduction 1.1 A Brief History 1.2 Data Examples 1.3 Exercises", " Chapter 1 Introduction library(ggplot2, quietly = TRUE) library(ggdag, quietly = TRUE) 1.1 A Brief History 1.2 Data Examples 1.2.1 Mortality Rates by Country We use this function to generate the mortability rates by age and country #&#39; Create dataset Mortability Rate by Country #&#39; #&#39; Create dataset Mortability Rate by Country. #&#39; #&#39; Create dataset Mortability Rate by Country as shown in section 1.2.1. #&#39; #&#39; @return Dataframe of mortability rates #&#39; @export #&#39; #&#39; @examples #&#39; data_mortability() data_mortability &lt;- function() { out &lt;- data.frame( &quot;T&quot; = c(TRUE, TRUE, FALSE, FALSE), &quot;H&quot; = c(FALSE, TRUE, FALSE, TRUE), &quot;deaths&quot; = c(756340, 2152660, 2923480, 7517520), &quot;population&quot; = c(282305227, 48262955, 1297258493, 133015479)) out$Y &lt;- out$deaths / out$population # verify with book check &lt;- c(0.002679, 0.0446, 0.002254, 0.05652) stopifnot(sum(abs(out$Y - check)) &lt; 0.0001) out } #&#39; Create Mortability by Country dataset for exposure modeling #&#39; #&#39; Create Mortability by Country dataset for exposure modeling. #&#39; #&#39; Create Mortability by Country dataset for exposure modeling as described #&#39; in section 6.2 of chapter 6. #&#39; #&#39; @return Dataframe of mortability rates and exposure model #&#39; @export #&#39; #&#39; @examples #&#39; data_mortability_exp() data_mortability_exp &lt;- function() { out &lt;- data.frame( &quot;H&quot; = c(0, 0, 0, 0, 1, 1, 1, 1), &quot;T&quot; = c(0, 0, 1, 1, 0, 0, 1, 1), &quot;Y&quot; = c(0, 1, 0, 1, 0, 1, 0, 1), &quot;n&quot; = c(1297258493 - 2923480, 2923480, 282305227 - 756340, 756340, 133015479 - 7517520, 7517520, 48262955 - 2152660, 2152660)) # compute proportion who died out$p &lt;- out$n / sum(out$n) stopifnot(sum(out$p) == 1) out } ## T H deaths population Y ## 1 TRUE FALSE 756340 282305227 0.002679157 ## 2 TRUE TRUE 2152660 48262955 0.044602739 ## 3 FALSE FALSE 2923480 1297258493 0.002253583 ## 4 FALSE TRUE 7517520 133015479 0.056516129 1.2.2 National Center for Education Statistics 1.2.3 Reducing Alcohol Consumption 1.2.3.1 The What-If? Study 1.2.3.1.1 The Double What-If? Study The code can be found in the file doublewhatifsim.R and is verified against the authors file just below. The DAG for the Double What-If? study in the dagitty version is scm &lt;- list() scm &lt;- within(scm, { the_nodes &lt;- c(&quot;U&quot; = &quot;Unmeasured, healthy behavior (U=1)&quot;, &quot;AD0&quot; = &quot;Adherence time 0&quot;, &quot;VL0&quot; = &quot;Viral Load time 0&quot;, &quot;T&quot; = &quot;Naltrexone (T=1)&quot;, &quot;A&quot; = &quot;Reduced drinking (A=1)&quot;, &quot;AD1&quot; = &quot;Adherence time 1&quot;, &quot;VL1&quot; = &quot;Viral Load time 1&quot;) coords &lt;- data.frame( name = names(the_nodes), x = c(2, 3, 4, 1, 2, 3, 4), y = c(2, 2, 2, 1, 1, 1, 1) ) dag &lt;- dagify( AD0 ~ U, VL0 ~ AD0, A ~ `T` + U, AD1 ~ A, VL1 ~ AD0 + AD1 + U, outcome = &quot;VL1&quot;, exposure = &quot;T&quot;, latent = &quot;U&quot;, coords = coords, labels = the_nodes) # status&#39; colors colrs &lt;- c(&quot;latent&quot; = &quot;palevioletred&quot;, &quot;exposure&quot; = &quot;mediumspringgreen&quot;, &quot;outcome&quot; = &quot;cornflowerblue&quot;) # plot the DAG plot &lt;- dag %&gt;% tidy_dagitty() %&gt;% ggdag_status(color = status, text = TRUE, node_size = 10, text_size = 3, text_col = &quot;black&quot;) + scale_color_manual(values = colrs, na.value = &quot;honeydew3&quot;) + scale_fill_manual(values = colrs, na.value = &quot;honeydew3&quot;) + ggdag::theme_dag_blank(panel.background = element_rect(fill=&quot;snow&quot;, color=&quot;snow&quot;)) + theme(legend.position = &quot;bottom&quot;, legend.title = element_blank()) + labs(title = &quot;The Double What-If? Study&quot;) }) scm$plot and the code for doublewhatifsim.R is #&#39; \\code{doublewhatifsim} script rewritten #&#39; #&#39; \\code{doublewhatifsim} script rewritten. #&#39; #&#39; Simulate the What-If study data. #&#39; #&#39; @param n Nb of observations. #&#39; @param seed Integer, the seed used for random numbers. #&#39; #&#39; @return Dataframe doublewhatifsim &lt;- function(n = 1000, seed = 444) { set.seed(seed) # variables each with probability 0.5 U &lt;- rbinom(n, size = 1, prob = 0.5) # probability of AD0 depends on U AD0prob &lt;- 0.2 + 0.6 * U # generate independent bernoulli variables with varying probabilities AD0 &lt;- rbinom(n, size = 1, prob = AD0prob) VL0prob &lt;- 0.8 - 0.4 * AD0 VL0 &lt;- rbinom(n, size = 1, prob = VL0prob) `T` &lt;- rbinom(n, size = 1, prob = 0.5) Aprob &lt;- 0.05 + `T` * U * 0.8 A &lt;- rbinom(n, size = 1, prob = Aprob) AD1prob &lt;- 0.1 + 0.8 * A AD1 &lt;- rbinom(n, size = 1, prob = AD1prob) VL1prob &lt;- VL0prob + 0.1 - 0.45 * AD1 VL1 &lt;- rbinom(n, size =1 , prob = VL1prob) data.frame( &quot;AD0&quot; = AD0, &quot;VL0&quot; = VL0, &quot;T&quot; = `T`, &quot;A&quot; = A, &quot;AD1&quot; = AD1, &quot;VL1&quot; = VL1 ) } which we verify against the raw data set provided by the author. bb &lt;- doublewhatifdat d &lt;- doublewhatifsim() stopifnot(identical(d, bb)) 1.2.4 General Social Survey 1.2.5 A Cancer Clinical Trial 1.3 Exercises The exercises are located in a separate project. "],["probability.html", "Chapter 2 Conditional Probability and Expectation 2.1 Conditional Probability 2.2 Conditional Expectation and the Law of Total expectation 2.3 Estimation 2.4 Sampling Distributions and the Bootstrap 2.5 Exercises", " Chapter 2 Conditional Probability and Expectation The mortality data was given in chapter 1, section 1.2.1. data(&quot;mortality&quot;, package = &quot;fciR&quot;) dataMortality &lt;- mortality 2.1 Conditional Probability 2.1.1 Law of total probability It is important to note that \\(\\sum_i{H_i} = H\\), that is \\(H\\) can be partitioned in \\(i\\) non-overlapping partitions. Then the law of total probabilities is \\[ \\begin{align*} P(A) &amp;= \\sum_i{P(A \\cap H_i)}= \\sum_i{P(A \\mid H_i) P(H_i)} \\\\ &amp;\\text{and we condition the whole expression with B} \\\\ P(A \\mid B) &amp;= \\sum_i{P(A \\cap H_i \\mid B)}= \\sum_i{P(A \\mid B, H_i) P(B,H_i)} \\\\ \\end{align*} \\] and the multiplication rule is \\[ \\begin{align*} P(A, B \\mid C) &amp;= \\frac{P(A, B, C)}{P(C)} \\\\ &amp;= \\frac{P(A \\mid B, C) P(B, C)}{P(C)} \\\\ &amp;= \\frac{P(A \\mid B, C) P(B \\mid C) P(C)}{P(C)} \\\\ &amp;= P(A \\mid B, C) P(B \\mid C) \\end{align*} \\] 2.2 Conditional Expectation and the Law of Total expectation The function expit() used by the author is actually the same as gtools::inv.logit(), boot::inv.logit() or stats::plogis(). In this project we use stats::plogis() because it is in base R and we want to minimize dependencies. 2.3 Estimation Using the What-if example we have \\[ \\begin{align*} X_i \\beta &amp;= X_{i,1} \\beta_i +\\ldots+X_{i, p}\\beta_p \\\\ &amp;\\therefore \\\\ X_i \\beta &amp;= \\beta_1 A_i + \\beta_2 T_i + \\beta_3 H_i \\\\ \\end{align*} \\] and \\[ X_i^T(Y_i - X_i \\beta) \\\\ \\therefore \\\\ \\begin{bmatrix} 1 \\cdot(Y_i - \\beta_1 - A_i \\beta_2 - T_i \\beta_3 - H_i \\beta_4) \\\\ A_i \\cdot(Y_i - \\beta_1 - A_i \\beta_2 - T_i \\beta_3 - H_i \\beta_4) \\\\ T_i \\cdot(Y_i - \\beta_1 - A_i \\beta_2 - T_i \\beta_3 - H_i \\beta_4)\\\\ H_i \\cdot(Y_i - \\beta_1 - A_i \\beta_2 - T_i \\beta_3 - H_i \\beta_4) \\end{bmatrix} \\] 2.4 Sampling Distributions and the Bootstrap The sim() function in section 2.4, p. 31 is coded in fciR::sim_intervals() and its alias fciR::sim(). Run and verify with authors results on p. 32 d &lt;- sim(nsim = 500, n = 500) stopifnot(abs(d$bad - 0.8374) &lt; 0.03, abs(d$good - 0.948) &lt; 0.03) d ## $bad ## [1] 0.85 ## ## $good ## [1] 0.954 and lmodboot() is fciR::boot_lmod() with the alias fciR::lmodboot() Run and verify against the authors results on p.34 data(&quot;whatifdat&quot;, package = &quot;fciR&quot;) message(&quot;this takes 10 sec.: we load a saved file instead&quot;) ## this takes 10 sec.: we load a saved file instead # startTime &lt;- Sys.time() # out &lt;- fciR::boot_est(whatifdat, func = fciR::prob_lmod, R = 500, conf = 0.95, # inv = &quot;expit&quot;, evars = &quot;logit&quot;, # outcome.name = &quot;Y&quot;, # input.names = c(&quot;T&quot;, &quot;A&quot;, &quot;H&quot;)) # endTime &lt;- Sys.time() # print(endTime - startTime) a_file &lt;- file.path(dir_data, &quot;chap02_lmodboot.rds&quot;) # saveRDS(out, file = a_file) out &lt;- readRDS(file = a_file) # check results with book stopifnot(abs(out[&quot;est&quot;] - 0.60596) &lt; 0.02, abs(out[&quot;lci&quot;] - 0.41638) &lt; 0.02, abs(out[&quot;uci&quot;] - 0.76823) &lt; 0.02) 2.5 Exercises The exercises are located in a separate project. "],["outcomes.html", "Chapter 3 Potential Outcomes and the Fundamental Problem of Causal Inference 3.1 Potential Outcomes and the Consistency Assumption 3.2 Circumventing the Fundamental Problem of Causal Inference 3.3 Effect Measures 3.4 Exercises", " Chapter 3 Potential Outcomes and the Fundamental Problem of Causal Inference library(fciR) 3.1 Potential Outcomes and the Consistency Assumption 3.2 Circumventing the Fundamental Problem of Causal Inference 3.3 Effect Measures Run the function to get the association measures data(&quot;gss&quot;, package = &quot;fciR&quot;) gssrcc &lt;- gss[, c(&quot;trump&quot;, &quot;gthsedu&quot;, &quot;magthsedu&quot;, &quot;white&quot;, &quot;female&quot;, &quot;gt65&quot;)] gssrcc &lt;- gss[complete.cases(gssrcc), ] stopifnot(nrow(gssrcc) == 2348 - 180) # see comment on p. 46 message(&quot;this takes 20 sec.: we load a saved file instead&quot;) ## this takes 20 sec.: we load a saved file instead startTime &lt;- Sys.time() # uncond &lt;- fciR::boot_est(gssrcc, func = fciR::meas_effect_uncond, R = 500, conf = 0.95, # outcome.name = &quot;trump&quot;, input.names = &quot;gthsedu&quot;) # endTime &lt;- Sys.time() # print(endTime - startTime) a_file &lt;- file.path(dir_data, &quot;chap03_bootu.rds&quot;) # saveRDS(uncond, file = a_file) uncond &lt;- readRDS(file = a_file) gt_measures(uncond, title = &quot;Table 3.2&quot;, subtitle = &quot;4 Association Measures Relating&lt;br&gt;&lt;em&gt;More than High School Education&lt;/em&gt; to &lt;em&gt;Voting for Trump&lt;/em&gt;&quot;) html { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif; } #rrkiiyrqsn .gt_table { display: table; border-collapse: collapse; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #rrkiiyrqsn .gt_heading { background-color: #DCDCDC; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #rrkiiyrqsn .gt_title { color: #333333; font-size: 125%; font-weight: bold; padding-top: 4px; padding-bottom: 4px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #rrkiiyrqsn .gt_subtitle { color: #333333; font-size: 85%; font-weight: bold; padding-top: 0; padding-bottom: 6px; border-top-color: #FFFFFF; border-top-width: 0; } #rrkiiyrqsn .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #rrkiiyrqsn .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #rrkiiyrqsn .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: bold; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #rrkiiyrqsn .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: bold; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #rrkiiyrqsn .gt_column_spanner_outer:first-child { padding-left: 0; } #rrkiiyrqsn .gt_column_spanner_outer:last-child { padding-right: 0; } #rrkiiyrqsn .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; } #rrkiiyrqsn .gt_group_heading { padding: 8px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; } #rrkiiyrqsn .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #rrkiiyrqsn .gt_from_md > :first-child { margin-top: 0; } #rrkiiyrqsn .gt_from_md > :last-child { margin-bottom: 0; } #rrkiiyrqsn .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #rrkiiyrqsn .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 12px; } #rrkiiyrqsn .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #rrkiiyrqsn .gt_first_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; } #rrkiiyrqsn .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #rrkiiyrqsn .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #rrkiiyrqsn .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #rrkiiyrqsn .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #rrkiiyrqsn .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #rrkiiyrqsn .gt_footnote { margin: 0px; font-size: 90%; padding: 4px; } #rrkiiyrqsn .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #rrkiiyrqsn .gt_sourcenote { font-size: 90%; padding: 4px; } #rrkiiyrqsn .gt_left { text-align: left; } #rrkiiyrqsn .gt_center { text-align: center; } #rrkiiyrqsn .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #rrkiiyrqsn .gt_font_normal { font-weight: normal; } #rrkiiyrqsn .gt_font_bold { font-weight: bold; } #rrkiiyrqsn .gt_font_italic { font-style: italic; } #rrkiiyrqsn .gt_super { font-size: 65%; } #rrkiiyrqsn .gt_footnote_marks { font-style: italic; font-weight: normal; font-size: 65%; } Table 3.2 4 Association Measures RelatingMore than High School Education to Voting for Trump Measure Estimate CI1 P0 0.233 (0.208, 0.256) P1 0.271 (0.244, 0.299) RD 0.038 (0.003, 0.075) RR 1.162 (1.012, 1.348) RR* 1.052 (1.004, 1.106) OR 1.222 (1.016, 1.491) Fundamentals of Causal Inference, Babette A. Brumback, 2022 1 95% confidence interval verify with authors results, p. 48-49 bb &lt;- data.frame( name = c(&quot;p0&quot;, &quot;p1&quot;, &quot;rd&quot;, &quot;rr&quot;, &quot;rrstar&quot;, &quot;or&quot;), est = c(0.23338, 0.27117, 0.037782, 1.1619, 1.0518, 1.221), lci = c(0.21030, 0.24095, 0.00078085, 1.0047, 1.0006, 1.0056), uci = c(0.25647, 0.30139, 0.07478354, 1.3437, 1.1057, 1.4853)) stopifnot( all(abs(uncond$est - bb$est) &lt; 0.01), all(abs(uncond$lci - bb$lci) &lt; 0.015), all(abs(uncond$uci - bb$uci) &lt; 0.02)) Now we estimate the four effect measures using conditional association measures. We notice that The function used in chapter 3 on p. 50-52 is called lmodboot.r(). The same name is used in chapter 2 on p.33-34 for a function computing only the estimand (sampling distribution) but not the association measures We therefore rename the lmodboot.r() of chapter 3 as bootc to show it relates to bootu with the c meaning conditional and avoid conflicting function names with lmodboot.r() of chapter 2 To use the function with conditioning on variables, i.e. filtering on variables, we note that \\[ \\begin{align*} Y &amp;= \\text{trump} \\\\ T &amp;= \\text{gthsedu} \\\\ H_1 &amp;= \\text{magthsedu} \\\\ H_2 &amp;= \\text{white} \\\\ H_3 &amp;= \\text{female} \\\\ H_4 &amp;= \\text{gt65} \\\\ \\end{align*} \\] Therefore \\[ \\begin{align*} E(Y &amp;\\mid T = 0, H_1 = 1, H_2 = 1, H_3 = 1, H_4 = 1) \\\\ &amp;\\therefore \\text{because T = 0} \\\\ Y &amp;\\sim H_1 + H_2 + H_3 + H_4 \\\\ \\text{trump} &amp;\\sim \\text{magthsedu} + \\text{white} + \\text{female} + \\text{gt65} \\\\ \\end{align*} \\] message(&quot;this takes 20 sec.: we load a saved file instead&quot;) ## this takes 20 sec.: we load a saved file instead # startTime &lt;- Sys.time() # condit &lt;- fciR::boot_est(gssrcc, func = fciR::meas_effect_cond, R = 500, conf = 0.95, # outcome.name = &quot;trump&quot;, exposure.name = &quot;gthsedu&quot;, # confound.names = c(&quot;magthsedu&quot;, &quot;white&quot;, &quot;female&quot;, &quot;gt65&quot;)) # endTime &lt;- Sys.time() # print(endTime - startTime) a_file &lt;- file.path(dir_data, &quot;chap03_bootc.rds&quot;) # saveRDS(condit, file = a_file) condit &lt;- readRDS(file = a_file) gt_measures(condit, title = &quot;Table 3.3&quot;, subtitle = &quot;4 Conditional Association or Effect Measures&lt;br&gt; Relating &lt;em&gt;More than High School Education&lt;/em&gt; to &lt;em&gt;Voting for Trump&lt;/em&gt;&quot;) html { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif; } #wxppasnrtp .gt_table { display: table; border-collapse: collapse; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #wxppasnrtp .gt_heading { background-color: #DCDCDC; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #wxppasnrtp .gt_title { color: #333333; font-size: 125%; font-weight: bold; padding-top: 4px; padding-bottom: 4px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #wxppasnrtp .gt_subtitle { color: #333333; font-size: 85%; font-weight: bold; padding-top: 0; padding-bottom: 6px; border-top-color: #FFFFFF; border-top-width: 0; } #wxppasnrtp .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #wxppasnrtp .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #wxppasnrtp .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: bold; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #wxppasnrtp .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: bold; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #wxppasnrtp .gt_column_spanner_outer:first-child { padding-left: 0; } #wxppasnrtp .gt_column_spanner_outer:last-child { padding-right: 0; } #wxppasnrtp .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; } #wxppasnrtp .gt_group_heading { padding: 8px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; } #wxppasnrtp .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #wxppasnrtp .gt_from_md > :first-child { margin-top: 0; } #wxppasnrtp .gt_from_md > :last-child { margin-bottom: 0; } #wxppasnrtp .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #wxppasnrtp .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 12px; } #wxppasnrtp .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #wxppasnrtp .gt_first_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; } #wxppasnrtp .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #wxppasnrtp .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #wxppasnrtp .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #wxppasnrtp .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #wxppasnrtp .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #wxppasnrtp .gt_footnote { margin: 0px; font-size: 90%; padding: 4px; } #wxppasnrtp .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #wxppasnrtp .gt_sourcenote { font-size: 90%; padding: 4px; } #wxppasnrtp .gt_left { text-align: left; } #wxppasnrtp .gt_center { text-align: center; } #wxppasnrtp .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #wxppasnrtp .gt_font_normal { font-weight: normal; } #wxppasnrtp .gt_font_bold { font-weight: bold; } #wxppasnrtp .gt_font_italic { font-style: italic; } #wxppasnrtp .gt_super { font-size: 65%; } #wxppasnrtp .gt_footnote_marks { font-style: italic; font-weight: normal; font-size: 65%; } Table 3.3 4 Conditional Association or Effect Measures Relating More than High School Education to Voting for Trump Measure Estimate CI1 P0 0.255 (0.182, 0.322) P1 0.301 (0.23, 0.369) RD 0.046 (0.005, 0.091) RR 1.182 (1.009, 1.394) RR* 1.066 (1.005, 1.134) OR 1.261 (1.018, 1.576) Fundamentals of Causal Inference, Babette A. Brumback, 2022 1 95% confidence interval verify with authors results, p.52 bb &lt;- data.frame( name = c(&quot;p0&quot;, &quot;p1&quot;, &quot;rd&quot;, &quot;rr&quot;, &quot;rrstar&quot;, &quot;or&quot;), est = c(0.25458, 0.30101, 0.046438, 1.1824, 1.0664, 1.261), lci = c(0.18518, 0.22995, 0.0022706, 1.0039, 1.0018, 1.0091), uci = c(0.32397, 0.37208, 0.0906057, 1.3927, 1.1352, 1.5758)) stopifnot( all(abs(condit$est - bb$est) &lt; 0.01), all(abs(condit$lci - bb$lci) &lt; 0.015), all(abs(condit$uci - bb$uci) &lt; 0.02)) 3.4 Exercises The exercises are located in a separate project. "],["measures.html", "Chapter 4 Effect-Measure Modification and Causal Interaction 4.1 Effect-Measure Modification and Statistical Interaction 4.2 Qualitative Agreement of Effect Measures in Modification 4.3 Causal Interaction 4.4 Exercises", " Chapter 4 Effect-Measure Modification and Causal Interaction library(fciR) library(tidyr) library(ggvenn, quietly = TRUE) 4.1 Effect-Measure Modification and Statistical Interaction 4.1.1 RECOVERY trial Get the data.frame for RECOVERY trial data(&quot;recovery&quot;, package = &quot;fciR&quot;) run boot(), alias meas_effect_modif() with the RECOVERY data set recovery.out &lt;- boot_est(data = recovery, func = meas_effect_modif, R = 100, conf = 0.95, inv = &quot;exp&quot;, evars = &quot;modifier&quot;, outcome.name = &quot;Y&quot;, exposure.name = &quot;T&quot;, modifier.name = &quot;M&quot;) verify the results with the authors on p. 65. bb &lt;- data.frame( estimator = c(&quot;EYT0&quot;, &quot;EYT0&quot;, &quot;EYT1&quot;, &quot;EYT1&quot;, &quot;RD&quot;, &quot;RD&quot;, &quot;EYT0&quot;, &quot;EYT1&quot;, &quot;RD&quot;, &quot;RR&quot;, &quot;RR&quot;, &quot;RR&quot;, &quot;RR*&quot;, &quot;RR*&quot;, &quot;RR*&quot;, &quot;OR&quot;, &quot;OR&quot;, &quot;OR&quot;), group = c(&quot;M0&quot;, &quot;M1&quot;, &quot;M0&quot;, &quot;M1&quot;, &quot;M0&quot;, &quot;M1&quot;, &quot;diff&quot;, &quot;diff&quot;, &quot;diff&quot;, &quot;M0&quot;, &quot;M1&quot;, &quot;diff&quot;, &quot;M0&quot;, &quot;M1&quot;, &quot;diff&quot;, &quot;M0&quot;, &quot;M1&quot;, &quot;diff&quot;), est = c(0.784, 0.593, 0.793, 0.735, 0.01, 0.142, -0.191, -0.059, 0.132, 1.012, 1.239, 1.224, 1.046, 1.533, 1.466, 1.059, 1.9, 1.794) ) ids &lt;- match(paste(bb$estimator, bb$group, sep = &quot;.&quot;), recovery.out$name) comp &lt;- data.frame(bb = bb, d = recovery.out[ids, &quot;est&quot;]) comp$dev &lt;- abs(comp$bb.est - comp$d) stopifnot(sum(comp$dev) &lt; 0.01) # comp and we communicate the results in a table # reformat to use for table and plot recovery.out &lt;- recovery.out %&gt;% separate(col = &quot;name&quot;, into = c(&quot;estimator&quot;, &quot;group&quot;), sep = &quot;[.]&quot;, remove = TRUE) fciR::gt_measures_colgrp(recovery.out, var_grp = &quot;group&quot;, title = &quot;Table 4.2 RECOVERY Trial&quot;, subtitle = &quot;Effect-measure Modification&quot;) html { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif; } #ptphparmag .gt_table { display: table; border-collapse: collapse; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #ptphparmag .gt_heading { background-color: #DCDCDC; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #ptphparmag .gt_title { color: #333333; font-size: 125%; font-weight: bold; padding-top: 4px; padding-bottom: 4px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #ptphparmag .gt_subtitle { color: #333333; font-size: 85%; font-weight: bold; padding-top: 0; padding-bottom: 6px; border-top-color: #FFFFFF; border-top-width: 0; } #ptphparmag .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #ptphparmag .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #ptphparmag .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: bold; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #ptphparmag .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: bold; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #ptphparmag .gt_column_spanner_outer:first-child { padding-left: 0; } #ptphparmag .gt_column_spanner_outer:last-child { padding-right: 0; } #ptphparmag .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; } #ptphparmag .gt_group_heading { padding: 8px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; } #ptphparmag .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #ptphparmag .gt_from_md > :first-child { margin-top: 0; } #ptphparmag .gt_from_md > :last-child { margin-bottom: 0; } #ptphparmag .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #ptphparmag .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 12px; } #ptphparmag .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #ptphparmag .gt_first_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; } #ptphparmag .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #ptphparmag .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #ptphparmag .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #ptphparmag .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #ptphparmag .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #ptphparmag .gt_footnote { margin: 0px; font-size: 90%; padding: 4px; } #ptphparmag .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #ptphparmag .gt_sourcenote { font-size: 90%; padding: 4px; } #ptphparmag .gt_left { text-align: left; } #ptphparmag .gt_center { text-align: center; } #ptphparmag .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #ptphparmag .gt_font_normal { font-weight: normal; } #ptphparmag .gt_font_bold { font-weight: bold; } #ptphparmag .gt_font_italic { font-style: italic; } #ptphparmag .gt_super { font-size: 65%; } #ptphparmag .gt_footnote_marks { font-style: italic; font-weight: normal; font-size: 65%; } Table 4.2 RECOVERY Trial Effect-measure Modification Estimator M0 M1 diff Estimate CI1 Estimate CI1 Estimate CI1 EYT0 0.784 (0.771, 0.795) 0.593 (0.557, 0.628) -0.191 (-0.228, -0.153) EYT1 0.793 (0.777, 0.810) 0.735 (0.685, 0.776) -0.059 (-0.113, -0.013) RD 0.010 (-0.010, 0.030) 0.142 (0.086, 0.190) 0.132 (0.069, 0.186) RR 1.012 (0.988, 1.039) 1.239 (1.140, 1.331) 1.224 (1.117, 1.325) RR* 1.046 (0.954, 1.152) 1.533 (1.254, 1.807) 1.466 (1.155, 1.784) OR 1.059 (0.943, 1.197) 1.900 (1.437, 2.395) 1.794 (1.296, 2.353) Fundamentals of Causal Inference, Babette A. Brumback, 2022 1 95% confidence interval plotting the results makes it easier to see the measures vary among the strata. We can clearly see here significant difference in effect measures between the 2 strata. It supports the observation in the text concerning the lack of effect of dexamethasone without intrusive mechanical ventilation (M0) vs its use with intrusive mechanical ventilation (M1) which is significant. fciR::ggp_measures_modif(recovery.out, title = &quot;RECOVERY trial&quot;) The gee::gee() function is used to find information on the coefficients and see if they are statistically significant. The same could be done withe glm::glm() but gee offers results with robust statistics which is very useful in practical terms. Luckily, the gee() works exactly like the glm() functions, with the same extractor functions coefficients(), effects(), etc. See the documentation of lm with ?lm for more details. We are going through an example just below to illustrate how tthe extractor functions are used which is not shown in the textbook. linmod &lt;- gee::gee(Y ~ `T` + M + `T` * M, id = id, data = recovery, family = gaussian) ## Beginning Cgee S-function, @(#) geeformula.q 4.13 98/01/27 ## running glm to get initial regression estimate ## (Intercept) T M T:M ## 0.78367235 0.00958608 -0.19070017 0.13200964 summary(linmod) ## ## GEE: GENERALIZED LINEAR MODELS FOR DEPENDENT DATA ## gee S-function, version 4.13 modified 98/01/27 (1998) ## ## Model: ## Link: Identity ## Variance to Mean Relation: Gaussian ## Correlation Structure: Independent ## ## Call: ## gee::gee(formula = Y ~ T + M + T * M, id = id, data = recovery, ## family = gaussian) ## ## Summary of Residuals: ## Min 1Q Median 3Q Max ## -0.7932584 0.2067416 0.2163277 0.2163277 0.4070278 ## ## ## Coefficients: ## Estimate Naive S.E. Naive z Robust S.E. Robust z ## (Intercept) 0.78367235 0.006975704 112.3431253 0.006826403 114.8001855 ## T 0.00958608 0.012170195 0.7876686 0.011778554 0.8138588 ## M -0.19070017 0.017545664 -10.8687918 0.019999408 -9.5352906 ## T:M 0.13200964 0.030881745 4.2746820 0.033074076 3.9913327 ## ## Estimated Scale Parameter: 0.1770267 ## Number of Iterations: 1 ## ## Working Correlation ## [,1] ## [1,] 1 To extract the coefficients from the gee object we use the extractor function coefficients() or its alias coef() coef(linmod) ## (Intercept) T M T:M ## 0.78367235 0.00958608 -0.19070017 0.13200964 and to extract the entire coefficient data to work with it, just use coefficients() with summary() coef(summary(linmod)) ## Estimate Naive S.E. Naive z Robust S.E. Robust z ## (Intercept) 0.78367235 0.006975704 112.3431253 0.006826403 114.8001855 ## T 0.00958608 0.012170195 0.7876686 0.011778554 0.8138588 ## M -0.19070017 0.017545664 -10.8687918 0.019999408 -9.5352906 ## T:M 0.13200964 0.030881745 4.2746820 0.033074076 3.9913327 and in this case we are concerned about how significant the interaction is. Therefore the Robust z is extracted with coefficients() alias coef() coef(summary(linmod))[, &quot;Robust z&quot;] ## (Intercept) T M T:M ## 114.8001855 0.8138588 -9.5352906 3.9913327 we see that \\(T:M\\) is 3.99 standard deviations away from zero which will give us the 2-sided p-value that is significant z &lt;- coef(summary(linmod))[&quot;T:M&quot;, &quot;Robust z&quot;] 2 * (1 - pnorm(z)) ## [1] 6.570304e-05 4.1.2 NCES We process the NCES data the same way we did for the RECOVERY trial. Run the bootsrap nces.out &lt;- boot_est(data = nces, func = meas_effect_modif, R = 100, conf = 0.95, inv = &quot;exp&quot;, evars = &quot;modifier&quot;, outcome.name = &quot;highmathsat&quot;, exposure.name = &quot;female&quot;, modifier.name = &quot;selective&quot;) verify the results with the authors on p. 70. bb &lt;- data.frame( estimator = c(&quot;EYT0&quot;, &quot;EYT0&quot;, &quot;EYT1&quot;, &quot;EYT1&quot;, &quot;RD&quot;, &quot;RD&quot;, &quot;EYT0&quot;, &quot;EYT1&quot;, &quot;RD&quot;, &quot;RR&quot;, &quot;RR&quot;, &quot;RR&quot;, &quot;RR*&quot;, &quot;RR*&quot;, &quot;RR*&quot;, &quot;OR&quot;, &quot;OR&quot;, &quot;OR&quot;), group = c(&quot;M0&quot;, &quot;M1&quot;, &quot;M0&quot;, &quot;M1&quot;, &quot;M0&quot;, &quot;M1&quot;, &quot;diff&quot;, &quot;diff&quot;, &quot;diff&quot;, &quot;M0&quot;, &quot;M1&quot;, &quot;diff&quot;, &quot;M0&quot;, &quot;M1&quot;, &quot;diff&quot;, &quot;M0&quot;, &quot;M1&quot;, &quot;diff&quot;), est = c(0.167, 0.675, 0.081, 0.345, -0.086, -0.33, 0.509, 0.264, -0.244, 0.486, 0.511, 1.052, 0.907, 0.496, 0.547, 0.44, 0.254, 0.576) ) ids &lt;- match(paste(bb$estimator, bb$group, sep = &quot;.&quot;), nces.out$name) comp &lt;- data.frame(bb = bb, d = nces.out[ids, &quot;est&quot;]) comp$dev &lt;- abs(comp$bb.est - comp$d) stopifnot(sum(comp$dev) &lt; 0.01) and the table is # reformat to use for table and plot nces.out &lt;- nces.out %&gt;% separate(col = &quot;name&quot;, into = c(&quot;estimator&quot;, &quot;group&quot;), sep = &quot;[.]&quot;, remove = TRUE) fciR::gt_measures_colgrp(nces.out, var_grp = &quot;group&quot;, title = &quot;Table 4.3 NCES data&quot;, subtitle = &quot;Effect-measure Modification&quot;) html { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif; } #mtrqdxzicm .gt_table { display: table; border-collapse: collapse; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #mtrqdxzicm .gt_heading { background-color: #DCDCDC; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #mtrqdxzicm .gt_title { color: #333333; font-size: 125%; font-weight: bold; padding-top: 4px; padding-bottom: 4px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #mtrqdxzicm .gt_subtitle { color: #333333; font-size: 85%; font-weight: bold; padding-top: 0; padding-bottom: 6px; border-top-color: #FFFFFF; border-top-width: 0; } #mtrqdxzicm .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #mtrqdxzicm .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #mtrqdxzicm .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: bold; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #mtrqdxzicm .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: bold; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #mtrqdxzicm .gt_column_spanner_outer:first-child { padding-left: 0; } #mtrqdxzicm .gt_column_spanner_outer:last-child { padding-right: 0; } #mtrqdxzicm .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; } #mtrqdxzicm .gt_group_heading { padding: 8px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; } #mtrqdxzicm .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #mtrqdxzicm .gt_from_md > :first-child { margin-top: 0; } #mtrqdxzicm .gt_from_md > :last-child { margin-bottom: 0; } #mtrqdxzicm .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #mtrqdxzicm .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 12px; } #mtrqdxzicm .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #mtrqdxzicm .gt_first_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; } #mtrqdxzicm .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #mtrqdxzicm .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #mtrqdxzicm .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #mtrqdxzicm .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #mtrqdxzicm .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #mtrqdxzicm .gt_footnote { margin: 0px; font-size: 90%; padding: 4px; } #mtrqdxzicm .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #mtrqdxzicm .gt_sourcenote { font-size: 90%; padding: 4px; } #mtrqdxzicm .gt_left { text-align: left; } #mtrqdxzicm .gt_center { text-align: center; } #mtrqdxzicm .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #mtrqdxzicm .gt_font_normal { font-weight: normal; } #mtrqdxzicm .gt_font_bold { font-weight: bold; } #mtrqdxzicm .gt_font_italic { font-style: italic; } #mtrqdxzicm .gt_super { font-size: 65%; } #mtrqdxzicm .gt_footnote_marks { font-style: italic; font-weight: normal; font-size: 65%; } Table 4.3 NCES data Effect-measure Modification Estimator M0 M1 diff Estimate CI1 Estimate CI1 Estimate CI1 EYT0 0.167 (0.135, 0.196) 0.675 (0.600, 0.740) 0.509 (0.426, 0.583) EYT1 0.081 (0.054, 0.109) 0.345 (0.247, 0.445) 0.264 (0.161, 0.367) RD -0.086 (-0.125, -0.042) -0.330 (-0.448, -0.200) -0.244 (-0.378, -0.104) RR 0.486 (0.337, 0.744) 0.511 (0.382, 0.711) 1.052 (0.611, 1.772) RR* 0.907 (0.867, 0.954) 0.496 (0.384, 0.667) 0.547 (0.418, 0.742) OR 0.440 (0.293, 0.708) 0.253 (0.151, 0.462) 0.576 (0.272, 1.234) Fundamentals of Causal Inference, Babette A. Brumback, 2022 1 95% confidence interval and we plot the results fciR::ggp_measures_modif(nces.out, title = &quot;NCES data&quot;) We observe that RD: Risk difference shows that using selection to accept more women seem to decrease the % of school with hogh math SAT OR and RRstar: Show the same results as RD RR: Indicates that selection, in relative terms has no significant effect 4.2 Qualitative Agreement of Effect Measures in Modification This section relies heavily on the paper from Shannin and Brumback (2021) Jake Shannin (2021). It used a Monte-Carlo simulation in java by jake running 1000000 times for six effect measures (the 4 in this chapter, the hazard ratio HR and the recovery ration HR*). For the purpose of this project we only simulate the 4 effect measures discussed so far (RD, RR, RR* and OR). We use R package MonteCarlo with 5000 repetitions. The distribution used for simulation is the beta distribution which is generally used for values in [0,1]. It is also used as a prior of binomial regression in Bayes analysis which is the subject covered a little later in this section. Regardless if the 6 effects measures from Jake Shannin (2021) or the 4 from Brumback (2022) are used, the process and conclusion are the same. We point out that using the distribution \\(Beta(1, 1) \\sim Uniform(0, 1)\\) is equivalent to running a grid search. It is also equivalent to the uniform distribution used in Jake Shannin (2021). 4.2.1 Simulate the effect measures We run the Monte-Carlo simulation without constraint and with \\(Beta(1,1)\\) which is equivalent to \\(Uniform(0,1)\\) used by Jake Shannin (2021). message(&quot;this takes 1 sec.: we load a saved file instead&quot;) ## this takes 1 sec.: we load a saved file instead # startTime &lt;- Sys.time() # gridsim &lt;- fciR::mc_beta_effect_measures(shape1 = 1, shape2 = 1, nrep = 5000) # endTime &lt;- Sys.time() # print(endTime - startTime) a_file &lt;- file.path(dir_data, &quot;chap04_gridsim.rds&quot;) # saveRDS(gridsim, file = a_file) gridsim &lt;- readRDS(file = a_file) which gives the vector of percentages unlist(gridsim) ## RD_RR RD_RRstar RD_OR RR_RRstar ## 0.0000 0.0000 0.0000 0.0000 ## RR_OR RRstar_OR RD_RR_vs_RRstar_OR RD_RRstar_vs_RR_OR ## 0.0000 0.0000 0.0260 0.0296 ## RD_OR_vs_RR_RRstar RD_RR_RRstar RD_RR_OR RD_RRstar_OR ## 0.0000 0.0000 0.0600 0.0546 ## RR_RRstar_OR RD_RR_RRstar_OR NONE ## 0.0000 0.8298 0.0000 For the following discussion, we must note the following about the vector of percentages returned by the simulation. Pairwise events: Some measures move as 1 pair in the same direction while all the other pairs move in different direction between each other. These are 6 possibilities named RD_RR,RD_RRstar, RD_OR, RR_RRstar, RR_OR, RRstar_OR. Opposite pairwise events: Some measures move as 2 pairs but each of the 2 pairs does not move in the same direction. There are 3 possibilities, called RD_RR_vs_RRstar_OR, RD_RRstar_vs_RR_OR and RD_OR_vs_RR_RRstar. These are the problematic ones as they cannot be represented in the Venn diagram of section 4.2. However we can distribute them to ensure probabilities add up to 1. For example RD_RR_vs_RRstar_OR will be split 50% between pairwise events RD_RR and 50% to pairwise eventRRstar_OR. This enforces the very important rule that probabilities must add up to 1 without consequences on the conclusions reached. 3-wise events: Some 3 measures move in the same direction together There are 4 possibilities called RD_RR_RRstar, RD_RR_OR, RD_RRstar_OR and RR_RRstar_OR. All events: Sometimes all measures move together. This is the possibility of interest discussed by Shannin and Brumback (2021). This possibility is called ALL. No event: The possibility NONE concerns the event that no pair of measures move in the same direction. It is impossible and represents the empty set \\(\\emptyset\\) which is one of the 3 conditions of a \\(\\sigma-field\\). Validation: The sum of the vectors elements must be one. The event definitions above ensure that the sample space is actually a \\(\\sigma-field\\). See Geoffrey R. Grimmet (2001), section 1.2. then we compare with the authors results bb &lt;- c(&quot;RD_RR&quot; = 0.026, &quot;RD_RRstar&quot; = 0.026, &quot;RD_OR&quot; = 0, &quot;RR_RRstar&quot; = 0, &quot;RR_OR&quot; = 0.026, &quot;RRstar_OR&quot; = 0.026, &quot;RD_RR_vs_RRstar_OR&quot; = 0, &quot;RD_RRstar_vs_RR_OR&quot; = 0, &quot;RD_OR_vs_RR_RRstar&quot; = 0, &quot;RD_RR_RRstar&quot; = 0, &quot;RD_RR_OR&quot; = 0.057, &quot;RD_RRstar_OR&quot; = 0.057, &quot;RR_RRstar_OR&quot; = 0, &quot;RD_RR_RRstar_OR&quot; = 0.833, &quot;NONE&quot; = 0) comp &lt;- data.frame(bb = round(bb, 4), sim = round(unlist(gridsim), 4)) comp ## bb sim ## RD_RR 0.026 0.0000 ## RD_RRstar 0.026 0.0000 ## RD_OR 0.000 0.0000 ## RR_RRstar 0.000 0.0000 ## RR_OR 0.026 0.0000 ## RRstar_OR 0.026 0.0000 ## RD_RR_vs_RRstar_OR 0.000 0.0260 ## RD_RRstar_vs_RR_OR 0.000 0.0296 ## RD_OR_vs_RR_RRstar 0.000 0.0000 ## RD_RR_RRstar 0.000 0.0000 ## RD_RR_OR 0.057 0.0600 ## RD_RRstar_OR 0.057 0.0546 ## RR_RRstar_OR 0.000 0.0000 ## RD_RR_RRstar_OR 0.833 0.8298 ## NONE 0.000 0.0000 The results from the Monte Carlo simulation above confirm the main conclusion from Jake Shannin (2021) that all effect measures move together 84% of the time. c(&quot;simulation&quot; = unname(unlist(gridsim[&quot;RD_RR_RRstar_OR&quot;])), &quot;author&#39;s&quot; = unname(bb[&quot;RD_RR_RRstar_OR&quot;])) ## simulation author&#39;s ## 0.8298 0.8330 We note that the sim adds up correctly to 1 but not the authors which adds up to 1.051. This is explained on p. 72 as a bit of arbitrary allocations. The Jake Shannin (2021) paper (caption figure 1) mentions that they do not add to 1 because they include events that are not mutually exclusive. c(&quot;simulation&quot; = sum(unlist(gridsim)), &quot;author&#39;s&quot; = sum(bb)) ## simulation author&#39;s ## 1.000 1.051 Actually, this is caused by the Opposite pairwise events which cannot be represented in the 4-set Venn diagram. For the purpose of this books we will simply split them between the events that makes them up without consequence on the conclusion. The Opposite pairwise events are the following # The events that pair of measures move together but in opposite # direction of another pair who also move together unlist(gridsim[c(&quot;RD_RR_vs_RRstar_OR&quot;, &quot;RD_RRstar_vs_RR_OR&quot;, &quot;RD_OR_vs_RR_RRstar&quot;)]) ## RD_RR_vs_RRstar_OR RD_RRstar_vs_RR_OR RD_OR_vs_RR_RRstar ## 0.0260 0.0296 0.0000 and when we split them between their 2 sub-events we can generate the Venn diagram as follows ggp_venn_sim(gridsim, n = 1000, fill_colr = c(&quot;blue&quot;, &quot;yellow&quot;, &quot;green&quot;, &quot;red&quot;), title = &quot;Venn diagram of effect measure modifications&quot;) now for constrained data message(&quot;this takes 1 sec.: we load a saved file instead&quot;) ## this takes 1 sec.: we load a saved file instead # startTime &lt;- Sys.time() # gridsim_const &lt;- fciR::mc_beta_effect_measures(shape1 = 1, shape2 = 1, nrep = 5000, # constrained = TRUE) # endTime &lt;- Sys.time() # print(endTime - startTime) a_file &lt;- file.path(dir_data, &quot;chap04_gridsim_const.rds&quot;) # saveRDS(gridsim_const, file = a_file) gridsim_const &lt;- readRDS(file = a_file) which gives the vector of percentages unlist(gridsim_const) ## RD_RR RD_RRstar RD_OR RR_RRstar ## 0.00000000 0.00000000 0.00000000 0.00000000 ## RR_OR RRstar_OR RD_RR_vs_RRstar_OR RD_RRstar_vs_RR_OR ## 0.00000000 0.00000000 0.06260032 0.04975923 ## RD_OR_vs_RR_RRstar RD_RR_RRstar RD_RR_OR RD_RRstar_OR ## 0.00000000 0.00000000 0.11597111 0.10393258 ## RR_RRstar_OR RD_RR_RRstar_OR NONE ## 0.00000000 0.66773676 0.00000000 and comparing to the authors results bb_const &lt;- c(&quot;RD_RR&quot; = 0.053, &quot;RD_RRstar&quot; = 0.053, &quot;RD_OR&quot; = 0.053, &quot;RR_RRstar&quot; = 0, &quot;RR_OR&quot; = 0.053, &quot;RRstar_OR&quot; = 0.0, &quot;RD_RR_vs_RRstar_OR&quot; = 0, &quot;RD_RRstar_vs_RR_OR&quot; = 0, &quot;RD_OR_vs_RR_RRstar&quot; = 0, &quot;RD_RR_RRstar&quot; = 0, &quot;RD_RR_OR&quot; = 0.114, &quot;RD_RRstar_OR&quot; = 0.114, &quot;RR_RRstar_OR&quot; = 0, &quot;RD_RR_RRstar_OR&quot; = 0.667, &quot;NONE&quot; = 0) sum(bb_const) ## [1] 1.107 comp &lt;- data.frame(bb = round(bb_const, 4), sim = round(unlist(gridsim_const), 4)) comp ## bb sim ## RD_RR 0.053 0.0000 ## RD_RRstar 0.053 0.0000 ## RD_OR 0.053 0.0000 ## RR_RRstar 0.000 0.0000 ## RR_OR 0.053 0.0000 ## RRstar_OR 0.000 0.0000 ## RD_RR_vs_RRstar_OR 0.000 0.0626 ## RD_RRstar_vs_RR_OR 0.000 0.0498 ## RD_OR_vs_RR_RRstar 0.000 0.0000 ## RD_RR_RRstar 0.000 0.0000 ## RD_RR_OR 0.114 0.1160 ## RD_RRstar_OR 0.114 0.1039 ## RR_RRstar_OR 0.000 0.0000 ## RD_RR_RRstar_OR 0.667 0.6677 ## NONE 0.000 0.0000 The results from the Monte Carlo simulation with the constrained data agree the authors result. c(&quot;simulation&quot; = unname(unlist(gridsim_const[&quot;RD_RR_RRstar_OR&quot;])), &quot;author&#39;s&quot; = unname(bb_const[&quot;RD_RR_RRstar_OR&quot;])) ## simulation author&#39;s ## 0.6677368 0.6670000 Again the Opposite pairwise events cannot be represented in the 4-set Venn diagram. # The events that pair of measures move together but in opposite # direction of another pair who also move together unlist(gridsim_const[c(&quot;RD_RR_vs_RRstar_OR&quot;, &quot;RD_RRstar_vs_RR_OR&quot;, &quot;RD_OR_vs_RR_RRstar&quot;)]) ## RD_RR_vs_RRstar_OR RD_RRstar_vs_RR_OR RD_OR_vs_RR_RRstar ## 0.06260032 0.04975923 0.00000000 but if we do it as mentioned above then we can show a Venn diagram as follows # This is a custom function using the venn package ggp_venn_sim(gridsim_const, fill_colr = c(&quot;cyan&quot;, &quot;gold&quot;, &quot;springgreen&quot;, &quot;hotpink&quot;), title = &quot;Venn diagram for constrained data&quot;) 4.2.2 Applications 4.2.2.1 Simulation of distribution of effect measures We use a parametric Monte Carlo simulation using the beta distribution to evaluate the effect of the distribution assumption on the effect-measure modifications. We run the Monte-Carlo simulation with 5000 repetitions, a grid of shape1 and shape2 parameters for the Beta distribution and no constraint. Namely mc_beta_effect_measures(shape1 = c(0.5, 1, 3, 5, 7), shape2 = c(0.5, 1, 3, 5, 7), nrep = 5000) message(&quot;this takes 25 sec.: we load a saved file instead&quot;) ## this takes 25 sec.: we load a saved file instead # startTime &lt;- Sys.time() # priorsim &lt;- fciR::mc_beta_effect_measures(shape1 = c(0.5, 1, 3, 5, 7), # shape2 = c(0.5, 1, 3, 5, 7), # nrep = 5000) # endTime &lt;- Sys.time() # print(endTime - startTime) a_file &lt;- file.path(dir_data, &quot;chap04_priorsim.rds&quot;) # saveRDS(priorsim, file = a_file) priorsim &lt;- readRDS(file = a_file) and we look at the matrix for the event RD_RR_RRstar_OR which represents the event that all effect measures move in the same direction. The matrix elements correspond to the percentage frequency of the event given the beta distribution with shape parameters shape1 = s1 with s1 indicated as column names, and shape2 = s1 parameter with s2 indicated in the row names. The beta distribution with shape1 = 1 and shape2 = 1 is similar to the uniform distribution on \\([0, 1]\\). Therefore this element is the one simulated by Shannon and Brumback, see Jake Shannin (2021) and, in fact, with 5000 repetitions nrep = 5000the measure is almost always very close to what is mentioned in Jake Shannin (2021). Also note that for large \\(shape1 = shape2 = \\text{large number}\\) the beta distribution is similar to the normal distribution with a mean of \\(shape1 / (shape1 + shape2)\\). The simulation shows that in that case the percentage of measures moving in the same directions is nearing 100%. See for example when \\(shape1 = shape2 = 7\\) in the matrix of results from the sim. here is the matrix of percentage of times that all measures move in the same direction, i.e. the event RD_RR_RRstar_OR round(priorsim[[&quot;RD_RR_RRstar_OR&quot;]], 2) ## s1=0.5 s1=1 s1=3 s1=5 s1=7 ## s2=0.5 0.78 0.81 0.82 0.83 0.83 ## s2=1 0.81 0.84 0.86 0.87 0.86 ## s2=3 0.82 0.86 0.90 0.91 0.91 ## s2=5 0.83 0.86 0.91 0.92 0.92 ## s2=7 0.83 0.87 0.91 0.93 0.93 and to show as a heatmap ggp_betasim(priorsim, var = &quot;RD_RR_RRstar_OR&quot;, colr = list(&quot;low&quot; = &quot;deepskyblue1&quot;, &quot;high&quot; = &quot;deepskyblue4&quot;)) and comparing with the author round(c(&quot;simulation&quot; = priorsim[[&quot;RD_RR_RRstar_OR&quot;]][&quot;s2=1&quot;, &quot;s1=1&quot;], &quot;author&#39;s&quot; = unname(bb[&quot;RD_RR_RRstar_OR&quot;])), 3) ## simulation author&#39;s ## 0.835 0.833 We can see that the range is wide and should be considered. range(priorsim[[&quot;RD_RR_RRstar_OR&quot;]]) ## [1] 0.7842 0.9310 Now we do it with constrained data message(&quot;this takes 30 sec.: we load a saved file instead&quot;) ## this takes 30 sec.: we load a saved file instead # startTime &lt;- Sys.time() # priorsim_const &lt;- fciR::mc_beta_effect_measures(shape1 = c(0.5, 1, 3, 5, 7), # shape2 = c(0.5, 1, 3, 5, 7), # nrep = 5000, constrained = TRUE) # endTime &lt;- Sys.time() # print(endTime - startTime) a_file &lt;- file.path(dir_data, &quot;chap04_priorsim_const.rds&quot;) # saveRDS(priorsim_const, file = a_file) priorsim_const &lt;- readRDS(file = a_file) ggp_betasim(priorsim_const, var = &quot;RD_RR_RRstar_OR&quot;, colr = list(&quot;low&quot; = &quot;lightsalmon1&quot;, &quot;high&quot; = &quot;lightsalmon4&quot;), title = &quot;Monte Carlo simulation. Constrained data.&quot;) and comparing with the author round(c(&quot;simulation&quot; = priorsim_const[[&quot;RD_RR_RRstar_OR&quot;]][&quot;s2=1&quot;, &quot;s1=1&quot;], &quot;author&#39;s&quot; = unname(bb_const[&quot;RD_RR_RRstar_OR&quot;])), 3) ## simulation author&#39;s ## 0.662 0.667 and the range is even larger and therefore more significant. range(priorsim_const[[&quot;RD_RR_RRstar_OR&quot;]]) ## [1] 0.5710824 0.8565217 4.2.2.2 Application: Data pre-processing (data cleaning) Unless the \\(p_0, p_1\\) obtained are uniformly distributed (not the most common scenario for sure) it seems from the results above that the likelihood of not having all effect measures moving in the same direction is low. Thus, it could be a good hint to uncover hidden processes in a data pre-processing routine. We note the important rule mentioned at the beginning of section 4.2 when relative risk \\(RR\\) and other relative risk \\(RR^*\\) both change in the same direction [] then so must the difference the risk difference and odds ratio. Another rule from section 4.2 can help in data cleaning When \\(RR_0\\) and \\(RR_1\\) are on opposite side of 1, that is, when in one stratum the treatment is helpful and in the other it is harmful, then all measures will automatically change together. Thus a quick, easy way to clean up potential data problems and obtain relevant details on outliers and hidden processes might be Exclude cases when \\(RR\\) and \\(RR^*\\) change in the same direction to reduce the data load. Exclude cases when \\(RR_0\\) and \\(RR_1\\) are on opposite side of 1 Investigate the remining cases asthey are good candidates for hidden processes 4.2.2.3 Application: Bayesian prior in Beta-binomial model If we use information from the population, or from expert knowledge, that effect measures should move in the same direction then a beta distribution with \\(shape1 &gt; 1, shape2 &gt; 1\\) would make sense and provide a better prior for the Beta-binomial model. On the contrary, if we wish that the model look into the unlikely events that effect measure do not move in the same directions, then a beta distribution with \\(shape1 \\leq 1, shape2 \\leq 1\\) could be supported by the results from above. 4.3 Causal Interaction 4.4 Exercises The exercises are located in a separate project. References "],["dag.html", "Chapter 5 Causal Directed Acyclic Graphs 5.1 Theory 5.2 Examples 5.3 Exercises", " Chapter 5 Causal Directed Acyclic Graphs library(fciR) library(ggdag) library(dagitty) library(ggplot2) library(simstudy) We use the dagitty and ggdag packages to analyse the DAG and plot them. We also sue the simstudy package from now on to perform the simulations. 5.1 Theory 5.1.1 Conditional Indepence and DAG Causal directed acyclic graphs provide a convenient and efficient way to represent statistical ans causal dependence. For example scm_5.1 &lt;- list() scm_5.1 &lt;- within(scm_5.1, { the_nodes &lt;- c(&quot;X1&quot; = &quot;&quot;, &quot;X2&quot; = &quot;&quot;, &quot;X3&quot; = &quot;&quot;, &quot;X4&quot; = &quot;&quot;) dag &lt;- dagify( X2 ~ X1, X3 ~ X2, X4 ~ X1 + X2, labels = the_nodes) text_labels &lt;- c(expression(X[1]), expression(X[2]), expression(X[3]), expression(X[4])) plot &lt;- fciR::ggp_dag(dag, text_labels = text_labels) }) Figure 5.1: Example of a Directed Acyclic Graph can be expressed in terms of conditional probabilities as \\[ \\begin{align*} P(X_1, X_2, X_3, X_4) = P(X_4 \\mid X_2, X_1)P(X_3 \\mid X_2)P(X_2 \\mid X_1)P(X_1) \\end{align*} \\] 5.1.2 D-Separation A path is said to be d-separated, or blocked,, by a set of variables \\(C\\) if and only if the path i) containis a chain as in figure 5.2a such that the midlle variable \\(Z\\) is in \\(C\\) or ii) contains a fork as in figure 5.2b such that such that the middle variable \\(Z\\) is not in \\(C\\) or iii) contains an inverted fork, or collider, as in figure 5.2c such that the midlle variable \\(Z\\) is not in \\(C\\) and such that no descendant of a collider is in \\(C\\). and we illustrate the 3 basic graphical structures as follows scm_5.2 &lt;- list() scm_5.2 &lt;- within(scm_5.2, { # CHAIN dagChain &lt;- dagify( Z ~ X1, X2 ~ Z) text_labels &lt;- c(expression(X[1]), expression(X[2]), &quot;Z&quot;) plotChain &lt;- ggp_dag(dagChain, text_size = 5, text_labels = text_labels) + theme(title = element_text(size = 10)) + labs(title = &quot;Chain: Z is an intermediate variable&quot;) # FORK dagFork &lt;- dagify( X1 ~ Z, X2 ~ Z) plotFork &lt;- ggp_dag(dagFork, text_size = 5, text_labels = text_labels) + theme(title = element_text(size = 10)) + labs(title = &quot;Fork: Z is a common cause&quot;) # COLLIDER dagColl &lt;- dagify( Z ~ X1, Z ~ X2) plotColl &lt;- ggp_dag(dagColl, text_size = 5, text_labels = text_labels) + theme(title = element_text(size = 10)) + labs(title = &quot;Collider: Z is a common effect&quot;) # DESCENDANT dagDesc &lt;- dagify( W ~ X1, W ~ X2, Z ~ W) text_labels &lt;- c(expression(X[1]), expression(X[2]), expression(X[3]), &quot;Z&quot;) plotDesc &lt;- ggp_dag(dagDesc, text_size = 5, text_labels = text_labels) + theme(title = element_text(size = 10)) + labs(title = &quot;Descendant: Z is an effect of a common effect&quot;) }) gridExtra::grid.arrange(scm_5.2$plotChain, scm_5.2$plotFork, scm_5.2$plotColl, scm_5.2$plotDesc, nrow = 2, ncol = 2) Figure 5.2: Graphical structures 5.1.3 Causal DAG with collider and for our first practice of d-separation we have a DAG with a collider scm_5.3 &lt;- list() scm_5.3 &lt;- within(scm_5.3, { dag &lt;- dagify( A ~ W1, Y ~ W3, W2 ~ W1 + W3, W4 ~ W2) text_labels &lt;- c(&quot;A&quot;, expression(W[1]), expression(W[2]), expression(W[3]), expression(W[4], &quot;Y&quot;)) plot &lt;- fciR::ggp_dag(dag, text_labels = text_labels) }) Figure 5.3: Causal DAG With Collider The conditional independences can be obtained using impliedConditionalIndependencies from thedagitty package. You must ensure that you use the parameter type = \"all.pairs explicitly. The default is type = \"missing.edge. We will not list all of them, just their number, 93. # use type = &quot;all.pairs&quot; to get everything. # impliedConditionalIndependencies uses type &quot;missing.edge&quot; by default. length(impliedConditionalIndependencies(scm_5.3$dag, type = &quot;all.pairs&quot;)) ## [1] 93 some of those independence are impliedConditionalIndependencies(scm_5.3$dag, type = &quot;missing.edge&quot;) ## A _||_ W2 | W1 ## A _||_ W3 ## A _||_ W4 | W2 ## A _||_ W4 | W1 ## A _||_ Y ## W1 _||_ W3 ## W1 _||_ W4 | W2 ## W1 _||_ Y ## W2 _||_ Y | W3 ## W3 _||_ W4 | W2 ## W4 _||_ Y | W3 ## W4 _||_ Y | W2 5.2 Examples 5.2.1 Causal DAG With Intermediate Value Here we have \\(A \\not\\!\\perp\\!\\!\\!\\perp Y \\mid M\\) because \\(M\\) is a collider and conditioning on \\(M\\) would open up the path. scm_5.4 &lt;- list() scm_5.4 &lt;- within(scm_5.4, { dag &lt;- dagify( M ~ A + H, Y ~ A + M + H) plot &lt;- fciR::ggp_dag(dag) }) Figure 5.4: Causal DAG With Intermediate Variable 5.2.2 A counfounder may occur after the exposure Figure 5.5 illustrates and unmeasured true confounder \\(U\\) of the effect of \\(A\\) on \\(Y\\) that can be handled by conditioning on the measured variable \\(Z\\), even if \\(Z\\) occur after \\(A\\). scm_5.5 &lt;- list() scm_5.5 &lt;- within(scm_5.5, { dag &lt;- dagify( A ~ U, Z ~ U, Y ~ A + Z, latent = &quot;U&quot;, exposure = &quot;A&quot;, outcome = &quot;Y&quot;) plot &lt;- fciR::ggp_dag(dag) }) Figure 5.5: Confounder May Occur After the Exposure 5.2.3 Potential Outcomes are the Ultimate Counfounder The collection of potential outcomes \\(\\{Y(a)\\}_{a \\in A}\\) can be viewed as the ultimate confounder, even if it is not a tue confounder. The unmeasured counfounder \\(U = \\{Y(a)\\}_{a \\in A}\\) will always block all backdoor paths from \\(A\\) to \\(Y\\), because \\(Y\\) is a deterministic function of \\(A\\) and \\(\\{Y(a)\\}_{a \\in A}\\); that is \\(Y = Y(A)\\), or, for binary \\(Y\\), \\(Y = AY(1) + (1-A)Y(0)\\) scm_5.6 &lt;- list() scm_5.6 &lt;- within(scm_5.6, { the_nodes &lt;- c(&quot;A&quot; = &quot;&quot;, &quot;Y&quot; = &quot;&quot;, &quot;U&quot; = &quot;(Y(0), y(1))&quot;) dag &lt;- dagify( A ~ U, Y ~ A + U, latent = &quot;U&quot;, labels = the_nodes) plot &lt;- fciR::ggp_dag(dag) }) Figure 5.6: One way to generate confounding and lets do the simulation of figure 5.6 on p. 88 with simstudy scm_5.6 &lt;- within(scm_5.6, { probY0 &lt;- 0.42 probY1 &lt;- 0.62 formulaA &lt;- &quot;(1-Y0) * (1- Y1) * 0.6307 + (1 - Y0) * Y1 * 0.4867 + Y0 * (1 - Y1) * 0.4699 + Y0 * Y1 * 0.4263&quot; set.seed(111) # generate the potential outcomes defs &lt;- defData(varname = &quot;Y0&quot;, dist = &quot;binomial&quot;, formula = &quot;..probY0&quot;, variance = 1) defs &lt;- defData(defs, varname = &quot;Y1&quot;, dist = &quot;binomial&quot;, formula = &quot;..probY1&quot;, variance = 1) defs &lt;- defData(defs, varname = &quot;probA&quot;, dist = &quot;nonrandom&quot;, formula = formulaA) defs &lt;- defData(defs, varname = &quot;A&quot;, dist = &quot;binomial&quot;, formula = &quot;probA&quot;, variance = 1) # Y must depend on A, Y1, Y0 in this way defs &lt;- defData(defs, varname = &quot;Y&quot;, dist = &quot;nonrandom&quot;, formula = &quot;A * Y1 + (1 - A) * Y0&quot;) # generate the data data &lt;- genData(1000, defs) # create the tabletbl &lt;- sim_5.6$data %&gt;% tbl &lt;- data %&gt;% group_by(A, Y0, Y1, Y) %&gt;% count(name = &quot;prob&quot;) %&gt;% ungroup() %&gt;% mutate(prob = prob / sum(prob)) stopifnot(near(sum(tbl$prob), 1)) # format the tableau summ &lt;- fciR::gt_probs(tbl, title = &quot;Table 5.1&quot;, subtitle = &quot;Simulation Probabilities for `sim1.r`&quot;) }) scm_5.6$summ html { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif; } #derlplfuuo .gt_table { display: table; border-collapse: collapse; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #derlplfuuo .gt_heading { background-color: #DCDCDC; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #derlplfuuo .gt_title { color: #333333; font-size: 125%; font-weight: bold; padding-top: 4px; padding-bottom: 4px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #derlplfuuo .gt_subtitle { color: #333333; font-size: 85%; font-weight: bold; padding-top: 0; padding-bottom: 6px; border-top-color: #FFFFFF; border-top-width: 0; } #derlplfuuo .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #derlplfuuo .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #derlplfuuo .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: bold; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #derlplfuuo .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: bold; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #derlplfuuo .gt_column_spanner_outer:first-child { padding-left: 0; } #derlplfuuo .gt_column_spanner_outer:last-child { padding-right: 0; } #derlplfuuo .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; } #derlplfuuo .gt_group_heading { padding: 8px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; } #derlplfuuo .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #derlplfuuo .gt_from_md > :first-child { margin-top: 0; } #derlplfuuo .gt_from_md > :last-child { margin-bottom: 0; } #derlplfuuo .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #derlplfuuo .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 12px; } #derlplfuuo .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #derlplfuuo .gt_first_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; } #derlplfuuo .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #derlplfuuo .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #derlplfuuo .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #derlplfuuo .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #derlplfuuo .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #derlplfuuo .gt_footnote { margin: 0px; font-size: 90%; padding: 4px; } #derlplfuuo .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #derlplfuuo .gt_sourcenote { font-size: 90%; padding: 4px; } #derlplfuuo .gt_left { text-align: left; } #derlplfuuo .gt_center { text-align: center; } #derlplfuuo .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #derlplfuuo .gt_font_normal { font-weight: normal; } #derlplfuuo .gt_font_bold { font-weight: bold; } #derlplfuuo .gt_font_italic { font-style: italic; } #derlplfuuo .gt_super { font-size: 65%; } #derlplfuuo .gt_footnote_marks { font-style: italic; font-weight: normal; font-size: 65%; } Table 5.1 Simulation Probabilities for `sim1.r` A Y0 Y1 Y prob 0 0 0 0 0.077 0 0 1 0 0.212 0 1 0 1 0.083 0 1 1 1 0.144 1 0 0 0 0.127 1 0 1 1 0.173 1 1 0 0 0.079 1 1 1 1 0.105 Fundamentals of Causal Inference, Babette A. Brumback, 2022 we also do it in base R with the script on p.88 sim1.r &lt;- function(n = 1000) { set.seed(111) probY0 &lt;- 0.42 probY1 &lt;- 0.62 Y0 &lt;- rbinom(n, size = 1, prob = probY0) Y1 &lt;- rbinom(n, size = 1, prob = probY1) probA &lt;- (1 - Y0) * (1 - Y1) * 0.6307 + (1 - Y0) * Y1 * 0.4867 + Y0 * (1- Y1) * 0.4699 + Y0 * Y1 * 0.4263 A &lt;- rbinom(n, size = 1, prob = probA) Y &lt;- A * Y1 + (1 - A) * Y0 data.frame(cbind(A, Y0, Y1, Y)) } and we obtain the same results as with simstudy tbl &lt;- sim1.r() %&gt;% group_by(A, Y0, Y1, Y) %&gt;% count(name = &quot;prob&quot;) %&gt;% ungroup() %&gt;% mutate(prob = prob / sum(prob)) stopifnot(near(sum(tbl$prob), 1)) tbl ## # A tibble: 8 x 5 ## A Y0 Y1 Y prob ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0 0 0 0 0.077 ## 2 0 0 1 0 0.212 ## 3 0 1 0 1 0.083 ## 4 0 1 1 1 0.144 ## 5 1 0 0 0 0.127 ## 6 1 0 1 1 0.173 ## 7 1 1 0 0 0.079 ## 8 1 1 1 1 0.105 but when compare with the authors bb_5.6 &lt;- data.frame( A = c(0, 0, 0, 0, 1, 1, 1, 1), Y0 = c(0, 0, 1, 1, 0, 0, 1, 1), Y1 = c(0, 1, 0, 1, 0, 1, 0, 1), Y = c(0, 0, 1, 1, 0, 1, 0, 1), prob = c(0.0814, 0.1846, 0.0846, 0.1494, 0.139, 0.175, 0.075, 0.111) ) bb_5.6 ## A Y0 Y1 Y prob ## 1 0 0 0 0 0.0814 ## 2 0 0 1 0 0.1846 ## 3 0 1 0 1 0.0846 ## 4 0 1 1 1 0.1494 ## 5 1 0 0 0 0.1390 ## 6 1 0 1 1 0.1750 ## 7 1 1 0 0 0.0750 ## 8 1 1 1 1 0.1110 it is different. Table 5.1 is entitled Simulation probabilities for sim1.r because they are simulated probabilities. If the simulation size is increased 10000 the results are more in line with the authors. data.frame(&quot;author&quot; = bb_5.6$prob, &quot;sim&quot; = scm_5.6$tbl$prob) %&gt;% mutate(diff = sim - author) ## author sim diff ## 1 0.0814 0.077 -0.0044 ## 2 0.1846 0.212 0.0274 ## 3 0.0846 0.083 -0.0016 ## 4 0.1494 0.144 -0.0054 ## 5 0.1390 0.127 -0.0120 ## 6 0.1750 0.173 -0.0020 ## 7 0.0750 0.079 0.0040 ## 8 0.1110 0.105 -0.0060 and we also confirm the theoretical probabilities of the first line in the table as follows \\[ \\begin{align*} \\text{using (5.1), p.81, we can write the joint distribution as} \\\\ P(Y = 0, A = 0, Y1 = 0, Y0 = 0) = \\\\ P(Y = 0 \\mid A = 0, Y1 = 0, Y0 = 0) P(A = 0 \\mid Y1 = 0, Y0 = 0)P(Y1 = 0 \\mid Y0 = 0)\\ P(Y0 =0) \\end{align*} \\] and \\[ P(Y = 0 \\mid A = 0, Y1 = 0, Y0 = 0)=1 \\] and from the simulation we have \\[ \\begin{align*} P(A = 1 \\mid Y0 = 0, Y1 = 0) &amp;= 0.6307 \\\\ P(A = 0 \\mid Y0 = 0, Y1 = 0) &amp;= - 0.6307 = 0.3693\\\\ P(A = 1 \\mid Y0 = 1, Y1 = 0) &amp;= 0.4699 \\\\ P(A = 0 \\mid Y0 = 1, Y1 = 0) &amp;= 1 - 0.4699 = 0.5301 \\\\ P(A = 1 \\mid Y0 = 0, Y1 = 1) &amp;= 0.4867 \\\\ P(A = 0 \\mid Y0 = 0, Y1 = 1) &amp;= 1 - 0.4867 = 0.5133 \\\\ P(A = 1 \\mid Y0 = 1, Y1 = 1) &amp;= 0.4263 \\\\ P(A = 0 \\mid Y0 = 1, Y1 = 1) &amp;= 1 - 0.4263 = 0.5737 \\end{align*} \\] and we note that \\(Y0\\) and \\(Y1\\) are independent, i.e. \\(P(Y1 \\mid Y0) = P(Y1)\\) so that \\[ \\begin{align*} P(Y0 = 1) &amp;= 0.42\\\\ P(Y0 = 0) &amp;= 1 - 0.42 = 0.58\\\\ P(Y1 = 1) &amp;= 0.62\\\\ P(Y1 = 0) &amp;= 1 - 0.62 = 0.38 \\end{align*} \\] and since \\(Y0\\) and \\(Y1\\) are independent, i.e. \\(P(Y1 \\mid Y0) = P(Y1)\\) then \\[ \\begin{align*} P(Y = 0, A = 0, Y1 = 0, Y0 = 0) &amp;= \\\\ P(Y = 0 \\mid A = 0, Y1 = 0, Y0 = 0) P(A = 0 \\mid Y1 = 0, Y0 = 0) \\cdot P(Y1 = 0 \\mid Y0 = 0)P(Y0 = 0) &amp;= \\\\ 1 \\cdot P(A = 0 \\mid Y1 = 0, Y0 = 0) \\cdot P(Y1 = 0)P(Y0 = 0) &amp;= \\\\ 1\\times 0.3693 \\times 0.58 \\times 0.38 &amp;= 0.0814 \\end{align*} \\] 5.2.4 Structural Causal Model 5.7 The causal DAG is scm_5.7 &lt;- list() scm_5.7 &lt;- within(scm_5.7, { dag &lt;- dagify( A ~ H, Y ~ A + H) plot &lt;- fciR::ggp_dag(dag) }) Figure 5.7: Another way to generate confounding and we simulate the model with simstudy (and with the authors script after) scm_5.7 &lt;- within(scm_5.7, { set.seed(222) # generate the confounder H first defs &lt;- defData(varname = &quot;H&quot;, dist = &quot;binomial&quot;, formula = 0.4, variance = 1) # let the treatment depend on the confounder formulaA &lt;- &quot;H * 0.8 + (1 - H) * 0.3&quot; defs &lt;- defData(defs, varname = &quot;A&quot;, dist = &quot;binomial&quot;, formula = formulaA, variance = 1) # let the outcome depend on the treatment and the confounder formulaY &lt;- &quot;A * (H * 0.5 + (1 - H) * 0.7) + (1 - A) * (H * 0.3 + (1 - H) * 0.5)&quot; defs &lt;- defData(defs, varname = &quot;Y&quot;, dist = &quot;binomial&quot;, formula = formulaY, variance = 1) # generate the data data &lt;- genData(1000, defs) # create the tabletbl &lt;- sim_5.6$data %&gt;% tbl &lt;- data %&gt;% group_by(A, H, Y) %&gt;% count(name = &quot;prob&quot;) %&gt;% ungroup() %&gt;% mutate(prob = prob / sum(prob)) stopifnot(near(sum(tbl$prob), 1)) # format the tableau summ &lt;- fciR::gt_probs(tbl, title = &quot;Table 5.2&quot;, subtitle = &quot;Simulation Probabilities for `sim2.r`&quot;) }) scm_5.7$summ html { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif; } #fpzmgpvcjo .gt_table { display: table; border-collapse: collapse; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #fpzmgpvcjo .gt_heading { background-color: #DCDCDC; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #fpzmgpvcjo .gt_title { color: #333333; font-size: 125%; font-weight: bold; padding-top: 4px; padding-bottom: 4px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #fpzmgpvcjo .gt_subtitle { color: #333333; font-size: 85%; font-weight: bold; padding-top: 0; padding-bottom: 6px; border-top-color: #FFFFFF; border-top-width: 0; } #fpzmgpvcjo .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #fpzmgpvcjo .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #fpzmgpvcjo .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: bold; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #fpzmgpvcjo .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: bold; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #fpzmgpvcjo .gt_column_spanner_outer:first-child { padding-left: 0; } #fpzmgpvcjo .gt_column_spanner_outer:last-child { padding-right: 0; } #fpzmgpvcjo .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; } #fpzmgpvcjo .gt_group_heading { padding: 8px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; } #fpzmgpvcjo .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #fpzmgpvcjo .gt_from_md > :first-child { margin-top: 0; } #fpzmgpvcjo .gt_from_md > :last-child { margin-bottom: 0; } #fpzmgpvcjo .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #fpzmgpvcjo .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 12px; } #fpzmgpvcjo .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #fpzmgpvcjo .gt_first_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; } #fpzmgpvcjo .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #fpzmgpvcjo .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #fpzmgpvcjo .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #fpzmgpvcjo .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #fpzmgpvcjo .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #fpzmgpvcjo .gt_footnote { margin: 0px; font-size: 90%; padding: 4px; } #fpzmgpvcjo .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #fpzmgpvcjo .gt_sourcenote { font-size: 90%; padding: 4px; } #fpzmgpvcjo .gt_left { text-align: left; } #fpzmgpvcjo .gt_center { text-align: center; } #fpzmgpvcjo .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #fpzmgpvcjo .gt_font_normal { font-weight: normal; } #fpzmgpvcjo .gt_font_bold { font-weight: bold; } #fpzmgpvcjo .gt_font_italic { font-style: italic; } #fpzmgpvcjo .gt_super { font-size: 65%; } #fpzmgpvcjo .gt_footnote_marks { font-style: italic; font-weight: normal; font-size: 65%; } Table 5.2 Simulation Probabilities for `sim2.r` A H Y prob 0 0 0 0.181 0 0 1 0.230 0 1 0 0.065 0 1 1 0.014 1 0 0 0.065 1 0 1 0.132 1 1 0 0.141 1 1 1 0.172 Fundamentals of Causal Inference, Babette A. Brumback, 2022 and with the script sim2.r in base R sim2.r &lt;- function(n = 1000) { set.seed(222) # generate the confounder first H &lt;- rbinom(n, size = 1, prob = 0.4) probA &lt;- H * 0.8 + (1 - H) * 0.3 A &lt;- rbinom(n, size = 1, prob = probA) probY &lt;- A * (H * 0.5 + (1 - H) * 0.7) + (1 - A) * (H * 0.3 + (1 - H) * 0.5) Y &lt;- rbinom(n, size = 1, prob = probY) data.frame(cbind(H, A, Y)) } with the same probabilities as simstudy tbl &lt;- sim2.r() %&gt;% group_by(A, H, Y) %&gt;% count(name = &quot;prob&quot;) %&gt;% ungroup() %&gt;% mutate(prob = prob / sum(prob)) stopifnot(near(sum(tbl$prob), 1)) tbl ## # A tibble: 8 x 4 ## A H Y prob ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 0 0 0 0.181 ## 2 0 0 1 0.23 ## 3 0 1 0 0.065 ## 4 0 1 1 0.014 ## 5 1 0 0 0.065 ## 6 1 0 1 0.132 ## 7 1 1 0 0.141 ## 8 1 1 1 0.172 and the author provides the theoretical probability table bb_5.7 &lt;- data.frame( A = c(0, 0, 0, 0, 1, 1, 1, 1), H = c(0, 0, 1, 1, 0, 0, 1, 1), Y = c(0, 1, 0, 1, 0, 1, 0, 1), prob = c(0.21, 0.21, 0.056, 0.024, 0.024, 0.126, 0.16, 0.16) ) bb_5.7 ## A H Y prob ## 1 0 0 0 0.210 ## 2 0 0 1 0.210 ## 3 0 1 0 0.056 ## 4 0 1 1 0.024 ## 5 1 0 0 0.024 ## 6 1 0 1 0.126 ## 7 1 1 0 0.160 ## 8 1 1 1 0.160 and computating the theoretical prob. as was donw above \\[ \\begin{align*} P(Y, A, H) = P(Y \\mid A, H)P(A \\mid H)P(H) \\\\ \\end{align*} \\] and from the simulation we have \\[ \\begin{align*} P(H = 1) = 0.4 \\\\ P(H = 0) = 0.6 \\\\ P(A = 1 \\mid H = 0) = 0.3 \\\\ P(A = 0 \\mid H = 0) = 1 - 0.3 = 0.7 \\\\ P(A = 1 \\mid H = 1) = 0.8 \\\\ P(A = 0 \\mid H = 1) = 1 - 0.8 = 0.2 \\\\ P(Y = 1 \\mid A = 1, H = 1) = 0.5\\\\ P(Y = 0 \\mid A = 1, H = 1) = 1 - 0.5 = 0.5\\\\ P(Y = 1 \\mid A = 1, H = 0) = 0.7\\\\ P(Y = 0 \\mid A = 1, H = 0) = 1 - 0.7 = 0.3\\\\ P(Y = 1 \\mid A = 0, H = 1) = 0.3\\\\ P(Y = 0 \\mid A = 0, H = 1) = 1 - 0.3 = 0.7\\\\ P(Y = 1 \\mid A = 0, H = 0) = 0.5\\\\ P(Y = 0 \\mid A = 0, H = 0) = 1 - 0.5 = 0.5\\\\ \\end{align*} \\] Therefore for row 1 of table 5.2 we have \\[ \\begin{align*} P(Y = 0, A = 0, H = 0) &amp;= P(Y = 0 \\mid A = 0, H = 0)P(A = 0 \\mid H = 0)P(H = 0) \\\\ &amp;= 0.5 \\times 0.7 \\times 0.6 = 0.21 \\end{align*} \\] and for row 4 of table 5.2 \\[ \\begin{align*} P(Y = 1, A = 0, H = 1) &amp;= P(Y = 1 \\mid A = 0, H = 1)P(A = 0 \\mid H = 1)P(H = 1) \\\\ &amp;= 0.3 \\times 0.2 \\times 0.4 = 0.024 \\end{align*} \\] Using either sim1.r or sim2.r we can get the joint probability of \\(A\\) and \\(Y\\) using the law of total probabilities. bb_5.6 %&gt;% group_by(A, Y) %&gt;% summarize(prob = sum(prob)) ## `summarise()` has grouped output by &#39;A&#39;. You can override using the `.groups` argument. ## # A tibble: 4 x 3 ## # Groups: A [2] ## A Y prob ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0 0 0.266 ## 2 0 1 0.234 ## 3 1 0 0.214 ## 4 1 1 0.286 bb_5.7 %&gt;% group_by(A, Y) %&gt;% summarize(prob = sum(prob)) ## `summarise()` has grouped output by &#39;A&#39;. You can override using the `.groups` argument. ## # A tibble: 4 x 3 ## # Groups: A [2] ## A Y prob ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0 0 0.266 ## 2 0 1 0.234 ## 3 1 0 0.184 ## 4 1 1 0.286 Now One might wonder if knowledge of \\((A, H, Y)\\) is equivalent to knowledge of \\((A, Y0, Y1, Y)\\) Given \\((A, Y)\\) we cannot recover both \\(Y0\\) and \\(Y1\\). For example we can recover \\(Y1 = 1\\) since \\[ \\begin{align*} P(Y1 = 1 \\mid A = 1, Y = 1) &amp;= \\frac{P(Y1 = 1, A = 1, Y = 1)}{P(A = 1, Y = 1)} \\\\ &amp;= \\frac{0.175 + 0.111}{0.175 + 0.111} = 1 \\end{align*} \\] but for \\(P(Y0 = 1 \\mid A = 1, Y = 1)\\) we have \\[ \\begin{align*} P(Y0 = 1 \\mid A = 1, Y = 1) &amp;= \\frac{P(Y0 = 1, A = 1, Y = 1)}{P(A = 1, Y = 1)} \\\\ &amp;= \\frac{0.111}{0.175 + 0.111} = 0.39 \\end{align*} \\] and so the likelihood that \\(Y0 = 1\\) is only 39% and it is therefore more likely that \\(Y0 = 0\\) . . . but not always. Does the additional knowledge of \\(H\\) help to identify \\(Y(0)\\)? We leave that as a question for the reader. If we include \\(H\\) in the DAG of figure 5.6 we obtain the DAG of figure 5.8 below. We observe that \\((Y(0), Y(1)) \\perp\\!\\!\\!\\perp A \\mid H\\). In addition, since \\(Y\\) is a collider \\((Y(0), Y(1)) \\not\\!\\perp\\!\\!\\!\\perp A \\mid Y\\), therefore if we use the data from figure 5.8 below (simall.r) we have \\[ \\begin{align*} P(Y0 = 1 \\mid H = 1) &amp;= \\frac{P(Y0 = 1, H = 1)}{P(H = 1)} \\\\ &amp;= \\frac{0.019 + 0.006 + 0.051 + 0.05}{0.031 + 0.02 + 0.019 + 0.006 + 0.109 + 0.117 + 0.051 + 0.05} \\\\ &amp;= \\frac{0.126}{0.403} = 0.31 \\end{align*} \\] Therefore \\(H\\) is not entirely sufficient to determine \\((Y(0), Y(1))\\) as it will do it only 31% of the time for \\(Y(0) = 1\\) and otherwise 69% of the time for \\(Y(0) = 0\\). 5.2.5 Potential Outcomes Behind the Scenes scm_5.8 &lt;- list() scm_5.8 &lt;- within(scm_5.8, { the_nodes &lt;- c(&quot;A&quot; = &quot;&quot;, &quot;Y&quot; = &quot;&quot;, &quot;U&quot; = &quot;(Y(0), y(1))&quot;) dag &lt;- dagify( A ~ H, Y ~ A + U, U ~ H, latent = &quot;U&quot;, labels = the_nodes) plot &lt;- fciR::ggp_dag(dag) }) Figure 5.8: Potential Outcomes Behind the Scenes scm_5.8 &lt;- within(scm_5.8, { set.seed(888) # generate the observed confounder H defs &lt;- defData(varname = &quot;H&quot;, dist = &quot;binomial&quot;, formula = 0.4, variance = 1) # let the treatment depend on the observed confounder formulaA &lt;- &quot;H * 0.8 + (1 - H) * 0.3&quot; defs &lt;- defData(defs, varname = &quot;A&quot;, dist = &quot;binomial&quot;, formula = formulaA, variance = 1) # generate the poential outcomes dependent on the observed confounder formulaY0 &lt;- &quot;H * 0.3 + (1 - H) * 0.5&quot; formulaY1 &lt;- &quot;H * 0.5 + (1 - H) * 0.7&quot; defs &lt;- defData(defs, varname = &quot;Y0&quot;, dist = &quot;binomial&quot;, formula = formulaY0, variance = 1) defs &lt;- defData(defs, varname = &quot;Y1&quot;, dist = &quot;binomial&quot;, formula = formulaY1, variance = 1) # let the outcome depend on the treatment and Y0, Y1 formulaY &lt;- &quot;A * Y1 + (1 - A) * Y0&quot; defs &lt;- defData(defs, varname = &quot;Y&quot;, dist = &quot;binomial&quot;, formula = formulaY, variance = 1) # generate the data data &lt;- genData(1000, defs) # create the tabletbl &lt;- sim_5.6$data %&gt;% tbl &lt;- data %&gt;% group_by(H, A, Y0, Y1, Y) %&gt;% count(name = &quot;prob&quot;) %&gt;% ungroup() %&gt;% mutate(prob = prob / sum(prob)) stopifnot(near(sum(tbl$prob), 1)) # format the tableau tbl &lt;- fciR::gt_probs(tbl, title = &quot;Table for `simall.r`&quot;, subtitle = &quot;Simulation Probabilities for `simall.r`&quot;) }) scm_5.8$tbl html { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif; } #rjnfbzjtxw .gt_table { display: table; border-collapse: collapse; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #rjnfbzjtxw .gt_heading { background-color: #DCDCDC; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #rjnfbzjtxw .gt_title { color: #333333; font-size: 125%; font-weight: bold; padding-top: 4px; padding-bottom: 4px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #rjnfbzjtxw .gt_subtitle { color: #333333; font-size: 85%; font-weight: bold; padding-top: 0; padding-bottom: 6px; border-top-color: #FFFFFF; border-top-width: 0; } #rjnfbzjtxw .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #rjnfbzjtxw .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #rjnfbzjtxw .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: bold; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #rjnfbzjtxw .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: bold; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #rjnfbzjtxw .gt_column_spanner_outer:first-child { padding-left: 0; } #rjnfbzjtxw .gt_column_spanner_outer:last-child { padding-right: 0; } #rjnfbzjtxw .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; } #rjnfbzjtxw .gt_group_heading { padding: 8px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; } #rjnfbzjtxw .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #rjnfbzjtxw .gt_from_md > :first-child { margin-top: 0; } #rjnfbzjtxw .gt_from_md > :last-child { margin-bottom: 0; } #rjnfbzjtxw .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #rjnfbzjtxw .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 12px; } #rjnfbzjtxw .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #rjnfbzjtxw .gt_first_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; } #rjnfbzjtxw .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #rjnfbzjtxw .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #rjnfbzjtxw .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #rjnfbzjtxw .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #rjnfbzjtxw .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #rjnfbzjtxw .gt_footnote { margin: 0px; font-size: 90%; padding: 4px; } #rjnfbzjtxw .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #rjnfbzjtxw .gt_sourcenote { font-size: 90%; padding: 4px; } #rjnfbzjtxw .gt_left { text-align: left; } #rjnfbzjtxw .gt_center { text-align: center; } #rjnfbzjtxw .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #rjnfbzjtxw .gt_font_normal { font-weight: normal; } #rjnfbzjtxw .gt_font_bold { font-weight: bold; } #rjnfbzjtxw .gt_font_italic { font-style: italic; } #rjnfbzjtxw .gt_super { font-size: 65%; } #rjnfbzjtxw .gt_footnote_marks { font-style: italic; font-weight: normal; font-size: 65%; } Table for `simall.r` Simulation Probabilities for `simall.r` H A Y0 Y1 Y prob 0 0 0 0 0 0.070 0 0 0 1 0 0.159 0 0 1 0 1 0.055 0 0 1 1 1 0.140 0 1 0 0 0 0.023 0 1 0 1 1 0.065 0 1 1 0 0 0.026 0 1 1 1 1 0.059 1 0 0 0 0 0.031 1 0 0 1 0 0.020 1 0 1 0 1 0.019 1 0 1 1 1 0.006 1 1 0 0 0 0.109 1 1 0 1 1 0.117 1 1 1 0 0 0.051 1 1 1 1 1 0.050 Fundamentals of Causal Inference, Babette A. Brumback, 2022 and with the script simall.r in base R simall.r &lt;- function(n = 1000) { set.seed(888) # generate the observed confounder H &lt;- rbinom(n, size = 1, prob = 0.4) # generate the treatment probA &lt;- H * 0.8 + (1 - H) * 0.3 A &lt;- rbinom(n, size = 1, prob = probA) # generate the poential outcomes dependent on the observed confounder probY0 &lt;- H * 0.3 + (1 - H) * 0.5 probY1 &lt;- H * 0.5 + (1 - H) * 0.7 Y0 &lt;- rbinom(n, size = 1, prob = probY0) Y1 &lt;- rbinom(n, size = 1, prob = probY1) # let the outcome depend on the treatment and Y0, Y1 probY &lt;- A * Y1 + (1 - A) * Y0 Y &lt;- rbinom(n, size = 1, prob = probY) data.frame(cbind(H, A, Y0, Y1, Y)) } and the causal DAG for the What-If? study is scm_5.9 &lt;- list() scm_5.9 &lt;- within(scm_5.9, { the_nodes &lt;- c(&quot;U&quot; = &quot;Unmeasured, healthy behavior (U=1)&quot;, &quot;AD0&quot; = &quot;Adherence time 0&quot;, &quot;VL0&quot; = &quot;Viral Load time 0&quot;, &quot;T&quot; = &quot;Naltrexone (T=1)&quot;, &quot;A&quot; = &quot;Reduced drinking (A=1)&quot;, &quot;AD1&quot; = &quot;Adherence time 1&quot;, &quot;VL1&quot; = &quot;Viral Load time 1&quot;) coords &lt;- data.frame( name = names(the_nodes), x = c(2, 3, 4, 1, 2, 3, 4), y = c(2, 2, 2, 1, 1, 1, 1) ) dag &lt;- dagify( AD0 ~ U, VL0 ~ AD0, A ~ `T` + U, AD1 ~ A, VL1 ~ AD0 + AD1 + U, outcome = &quot;VL1&quot;, exposure = &quot;T&quot;, latent = &quot;U&quot;, labels = the_nodes) text_labels &lt;- c(&quot;A&quot;, expression(AD[0]), expression(AD[1]), &quot;T&quot;, &quot;U&quot;, expression(VL[0]), expression(VL[1])) plot &lt;- fciR::ggp_dag(dag, text_labels = text_labels, text_size = 5) }) Figure 5.9: The Double What-If? Study 5.3 Exercises The exercises are located in a separate project. "],["backdoor.html", "Chapter 6 Backdoor Method via Standardization 6.1 Standardization via Outome Modeling 6.2 Standardization via Exposure Modeling 6.3 Doubly Robust Standardization 6.4 Exercises", " Chapter 6 Backdoor Method via Standardization Important note on the notation used. When the author uses \\(E(Y=t) \\mid T=t, H=h)\\) it means that we condition the data on \\(H=h\\) and we intervene on the \\(T\\) column and set it to \\(T=t\\). For example for equation (6.2) we have \\[ \\begin{align*} E(Y(t)) &amp;= E_H(E(Y(t) \\mid H)) \\\\ &amp;= E_H(E(Y(t) \\mid T = t, H)) \\end{align*} \\] which indicates that \\(T=t\\) means that we set \\(T=t\\), i.e. it is not a condition that doesnt involve a filter on the data. We know that because we have the \\(E(Y(t))\\) which tells us that. But then we continue with proof (6.2) by adding the thrd line \\[ \\begin{align*} E(Y(t)) &amp;= E_H(E(Y(t) \\mid H)) \\\\ &amp;= E_H(E(Y(t) \\mid T = t, H)) \\\\ &amp;= E_H(E(Y \\mid T = t, H)) \\end{align*} \\] and, for the unwary beginner, \\(E(Y \\mid T = t, H)\\) could mean that we are conditioning on \\(T=t\\), that is, we filter the \\(T\\) variable in the data. This is confusing. To facilitate the reading and learning experience in this study project, whenever such confusion happens, the notation fro Pearl, using the \\(do()\\) operator will be used. For example, the proof (6.2) becomes \\[ \\begin{align*} E(Y(t)) &amp;= E_H(E(Y(t) \\mid H)) \\\\ &amp;= E_H(E(Y(t) \\mid T = t, H)) \\\\ &amp;\\text{and we use the do() operator to make it clear} \\\\ &amp;\\text{that T=t is not a condition, it is an intervention} \\\\ &amp;\\text{whereas H is a condition} \\\\ &amp;= E_H(E(Y \\mid do(T = t), H)) \\end{align*} \\] 6.1 Standardization via Outome Modeling Standardization vis via outcome modelingis one way to estimate \\(E(Y(t))\\) \\[ \\begin{align*} &amp;\\text{by double expectation theorem} \\\\ &amp;E(Y(t)) = E_H E(Y(t) \\mid H) \\\\ &amp;\\text{by independence of T given H, (6.1)} \\\\ &amp;= E_HE(Y(t) \\mid T=t, H) \\\\ &amp;\\text{by consistency assumption} \\\\ &amp;= E_HE(Y \\mid do(T=t), H) \\end{align*} \\] and with a binary data set we can write \\[ \\begin{align*} E_H E(Y \\mid do(T=t), H) = E(Y \\mid do(T=t), H = 0) P(H = 0) + E(Y \\mid do(T=t), H = 1) P(H = 1) \\end{align*} \\] and using the example on p. 100 with the mortality data we first load the data set data(&quot;mortality_long&quot;, package = &quot;fciR&quot;) mortality &lt;- mortality_long and we begin by calculating \\(\\hat{E}(Y \\mid T=0, H=0)\\) mortality %&gt;% filter(`T` == 0, H == 0) %&gt;% summarize(EY = weighted.mean(Y, n)) ## EY ## 1 0.002253583 and for all permutations of \\(T\\) and \\(H\\) we have EYcondTH &lt;- mortality %&gt;% group_by(`T`, H) %&gt;% summarize(EYcond = weighted.mean(Y, n)) EYcondTH ## # A tibble: 4 x 3 ## # Groups: T [2] ## T H EYcond ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0 0 0.00225 ## 2 0 1 0.0565 ## 3 1 0 0.00268 ## 4 1 1 0.0446 and then we multiply the conditional expectations by the probabilities of \\(H\\). PH &lt;- mortality %&gt;% group_by(H) %&gt;% summarize(prob = sum(p)) PH ## # A tibble: 2 x 2 ## H prob ## &lt;dbl&gt; &lt;dbl&gt; ## 1 0 0.897 ## 2 1 0.103 and the multiplication EYH &lt;- dplyr::inner_join(EYcondTH, PH, by = c(&quot;H&quot;)) %&gt;% mutate(EYH = EYcond * prob) EYH ## # A tibble: 4 x 5 ## # Groups: T [2] ## T H EYcond prob EYH ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0 0 0.00225 0.897 0.00202 ## 2 0 1 0.0565 0.103 0.00582 ## 3 1 0 0.00268 0.897 0.00240 ## 4 1 1 0.0446 0.103 0.00459 and the final results are EYout &lt;- EYH %&gt;% group_by(`T`) %&gt;% summarize(EYout = sum(EYH)) EYout ## # A tibble: 2 x 2 ## T EYout ## &lt;dbl&gt; &lt;dbl&gt; ## 1 0 0.00784 ## 2 1 0.00700 Now, lets do it with raw data. For that we convert the mortality data to have 1 line per 10000 observations. mort &lt;- mortality %&gt;% select(H, `T`, Y, n) %&gt;% mutate(n = as.integer(n / 10000)) %&gt;% uncount(n) str(mort) ## &#39;data.frame&#39;: 176080 obs. of 3 variables: ## $ H: num 0 0 0 0 0 0 0 0 0 0 ... ## $ T: num 0 0 0 0 0 0 0 0 0 0 ... ## $ Y: num 0 0 0 0 0 0 0 0 0 0 ... and the function used to automate the process described above is as follows est_out_np &lt;- function(data, outcome, exposure, confound) { # compute the frequencies summ &lt;- data %&gt;% count({{outcome}}, {{exposure}}, {{confound}}) %&gt;% mutate(freq = n / sum(n)) # the expected value of the outcome given the exposure and confounds EYcond &lt;- summ %&gt;% group_by({{exposure}}, {{confound}}) %&gt;% summarize(EYcond = weighted.mean(x = {{outcome}}, w = n)) # the probabilities of the confound PH &lt;- summ %&gt;% group_by({{confound}}) %&gt;% summarize(prob = sum(freq)) # multiply the conditional expectation by the confound probabilities cnf &lt;- enquo(confound) EY &lt;- dplyr::inner_join(EYcond, PH, by = quo_name(cnf)) %&gt;% mutate(EY = EYcond * prob) %&gt;% group_by({{exposure}}) %&gt;% summarize(EY = sum(EY)) %&gt;% arrange({{exposure}}) %&gt;% pull(EY) %&gt;% setNames(c(&quot;EY0&quot;, &quot;EY1&quot;)) } mort.out.est &lt;- est_out_np(mort, outcome = Y, exposure = `T`, confound = H) mort.out.est ## EY0 EY1 ## 0.007831933 0.006969437 and we can see it gives the same results (the function is also found in fciR::backdr_out_np) message(&quot;This takes about 2 min. Load from file.&quot;) ## This takes about 2 min. Load from file. # startTime &lt;- Sys.time() # mort.out.np &lt;- fciR::boot_est( # mort, fciR::backdr_out_np, R = 500, conf = 0.95, outcome.name = &quot;Y&quot;, # exposure.name = &quot;T&quot;, confound.names = &quot;H&quot;) # endTime &lt;- Sys.time() # print(endTime - startTime) a_file &lt;- file.path(dir_data, &quot;chap06_mort_out_np.rds&quot;) # saveRDS(mort.out.np, file = a_file) mort.out.np &lt;- readRDS(file = a_file) html { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif; } #gxdvuyotxm .gt_table { display: table; border-collapse: collapse; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #gxdvuyotxm .gt_heading { background-color: #DCDCDC; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #gxdvuyotxm .gt_title { color: #333333; font-size: 125%; font-weight: bold; padding-top: 4px; padding-bottom: 4px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #gxdvuyotxm .gt_subtitle { color: #333333; font-size: 85%; font-weight: bold; padding-top: 0; padding-bottom: 6px; border-top-color: #FFFFFF; border-top-width: 0; } #gxdvuyotxm .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #gxdvuyotxm .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #gxdvuyotxm .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: bold; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #gxdvuyotxm .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: bold; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #gxdvuyotxm .gt_column_spanner_outer:first-child { padding-left: 0; } #gxdvuyotxm .gt_column_spanner_outer:last-child { padding-right: 0; } #gxdvuyotxm .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; } #gxdvuyotxm .gt_group_heading { padding: 8px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; } #gxdvuyotxm .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #gxdvuyotxm .gt_from_md > :first-child { margin-top: 0; } #gxdvuyotxm .gt_from_md > :last-child { margin-bottom: 0; } #gxdvuyotxm .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #gxdvuyotxm .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 12px; } #gxdvuyotxm .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #gxdvuyotxm .gt_first_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; } #gxdvuyotxm .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #gxdvuyotxm .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #gxdvuyotxm .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #gxdvuyotxm .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #gxdvuyotxm .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #gxdvuyotxm .gt_footnote { margin: 0px; font-size: 90%; padding: 4px; } #gxdvuyotxm .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #gxdvuyotxm .gt_sourcenote { font-size: 90%; padding: 4px; } #gxdvuyotxm .gt_left { text-align: left; } #gxdvuyotxm .gt_center { text-align: center; } #gxdvuyotxm .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #gxdvuyotxm .gt_font_normal { font-weight: normal; } #gxdvuyotxm .gt_font_bold { font-weight: bold; } #gxdvuyotxm .gt_font_italic { font-style: italic; } #gxdvuyotxm .gt_super { font-size: 65%; } #gxdvuyotxm .gt_footnote_marks { font-style: italic; font-weight: normal; font-size: 65%; } Mortality MortalityStandardized Estimates via Outcome ModelingNon Parametric Without Regression Measure Estimate CI1 EY0 0.007832 (0.007367, 0.008308) EY1 0.006969 (0.006137, 0.007798) RD -0.000862 (-0.001804, 6.5e-05) RR 0.889874 (0.781363, 1.014305) RR* 0.999131 (0.998184, 1.000065) OR 0.889102 (0.779946, 1.014369) Fundamentals of Causal Inference, Babette A. Brumback, 2022 1 95% confidence interval and we now do it with the function fciR::backdr_out_npr. That function works exactly as the function standr in the book. message(&quot;This takes about 3 min. Load from file.&quot;) ## This takes about 3 min. Load from file. # startTime &lt;- Sys.time() # mort.out.npr &lt;- fciR::boot_est( # mort, fciR::backdr_out_npr, R = 500, conf = 0.95, outcome.name = &quot;Y&quot;, # exposure.name = &quot;T&quot;, confound.names = &quot;H&quot;, interactions = list(c(&quot;T&quot;, &quot;H&quot;))) # endTime &lt;- Sys.time() # print(endTime - startTime) a_file &lt;- file.path(dir_data, &quot;chap06_mort_out_npr.rds&quot;) # saveRDS(mort.out.npr, file = a_file) mort.out.npr &lt;- readRDS(file = a_file) and the results are the same again. In conclusion pretty much any of the function. The function fciR::backdr_out_npr seems faster. The function fciR::backdr_out_np is actually useful as a double check and it actually uses a pure application of probabilities. Examples What-if? Study data(&quot;whatifdat&quot;, package = &quot;fciR&quot;) Non-parametric With Regression backdr_out_npr whatif.out &lt;- fciR::boot_est( whatifdat, fciR::backdr_out_npr, R = 500, conf = 0.95, outcome.name = &quot;Y&quot;, exposure.name = &quot;A&quot;, confound.names = &quot;H&quot;, interactions = list(c(&quot;A&quot;, &quot;H&quot;))) # whatif.out and we compare with the authors comp &lt;- data.frame( name = c(&quot;EY0&quot;, &quot;EY1&quot;, &quot;RD&quot;, &quot;RR&quot;), auth = c(0.375, 0.289, -0.086, 0.77), est = whatif.out$est[whatif.out$name %in% c(&quot;EY0&quot;, &quot;EY1&quot;, &quot;RD&quot;, &quot;RR&quot;)] ) stopifnot(sum(abs(comp$auth - comp$est)) &lt; 0.01) and the results are presented in table 6.1 where we observe a reduction of the viral load but the difference is not statistically significant. Non-parametric Without Regression backdr_out_np message(&quot;This takes about 15 sec.. Load from file.&quot;) ## This takes about 15 sec.. Load from file. # startTime &lt;- Sys.time() # whatif.out.np &lt;- fciR::boot_est( # whatifdat, fciR::backdr_out_np, R = 500, conf = 0.95, outcome.name = &quot;Y&quot;, # exposure.name = &quot;A&quot;, confound.names = &quot;H&quot;) # endTime &lt;- Sys.time() # print(endTime - startTime) a_file &lt;- file.path(dir_data, &quot;chap06_whatif_out_np.rds&quot;) # saveRDS(whatif.out.np, file = a_file) whatif.out.np &lt;- readRDS(file = a_file) T0.he results are different when we dont use linear regression!. Not a very large difference but a significant one. Double What-if? Study data(&quot;doublewhatifdat&quot;, package = &quot;fciR&quot;) Non-parametric With Regression backdr_out_npr doublewhatif.out &lt;- fciR::boot_est( doublewhatifdat, fciR::backdr_out_npr, R = 500, conf = 0.95, outcome.name = &quot;VL1&quot;, exposure.name = &quot;A&quot;, confound.names = &quot;AD0&quot;, interactions = list(c(&quot;A&quot;, &quot;AD0&quot;))) Non-parametric Without Regression backdr_out_np message(&quot;This takes about 15 sec.. Load from file.&quot;) ## This takes about 15 sec.. Load from file. # startTime &lt;- Sys.time() # doublewhatif.out.np &lt;- fciR::boot_est( # doublewhatifdat, fciR::backdr_out_np, R = 500, conf = 0.95, outcome.name = &quot;VL1&quot;, # exposure.name = &quot;A&quot;, confound.names = &quot;AD0&quot;) # endTime &lt;- Sys.time() # print(endTime - startTime) a_file &lt;- file.path(dir_data, &quot;chap06_doublewhatif_out_np.rds&quot;) # saveRDS(doublewhatif.out.np, file = a_file) doublewhatif.out.np &lt;- readRDS(file = a_file) and the results are the same For comparisons, we repeat the standardization with \\(H = VL_0\\) doublewhatif.out &lt;- fciR::boot_est( doublewhatifdat, fciR::backdr_out_npr, R = 500, conf = 0.95, outcome.name = &quot;VL1&quot;, exposure.name = &quot;A&quot;, confound.names = &quot;VL0&quot;, interactions = list(c(&quot;A&quot;, &quot;VL0&quot;))) 6.1.1 Average Effect of Treatment on the Treated The function bootstandatt described in section 6.1.1 is not necessary, see the function bootstand in the previous section which can do it with the addition of the argument att. What-if? Study whatif.att &lt;- fciR::boot_est( whatifdat, fciR::backdr_out_npr, R = 500, conf = 0.95, outcome.name = &quot;Y&quot;, exposure.name = &quot;A&quot;, confound.names = &quot;H&quot;, interactions = list(c(&quot;A&quot;, &quot;H&quot;)), att = TRUE) and we compare with the authors comp &lt;- data.frame( name = c(&quot;EY0&quot;, &quot;EY1&quot;, &quot;RD&quot;, &quot;RR&quot;), auth = c(0.361, 0.276, -0.085, 0.765), est = whatif.att$est[whatif.att$name %in% c(&quot;EY0&quot;, &quot;EY1&quot;, &quot;RD&quot;, &quot;RR&quot;)] ) stopifnot(sum(abs(comp$auth - comp$est)) &lt; 0.01) and the results are presented in table 6.1 df &lt;- whatif.att tbl &lt;- fciR::gt_measures(df, title = &quot;Table 6.4&quot;, subtitle = paste(&quot;What-If Study&quot;, &quot;Standardized ATT estimates&quot;, &quot;Non Parametric With Regression&quot;, sep = &quot;&lt;br&gt;&quot;)) p &lt;- fciR::ggp_measures(df, title = NULL, subtitle = NULL) tbl &lt;- fciR::gt2ggp(tbl) p + tbl + plot_annotation(title = &quot;What-If Study&quot;, subtitle = &quot;Standardized ATT Estimates, 95% confidence interval&quot;) &amp; theme(title = element_text(color = &quot;midnightblue&quot;, size = rel(0.9))) It can also be done using a non-parametric method without regression. That is following pure probabilities from the data. message(&quot;This takes about 8 sec.. Load from file.&quot;) ## This takes about 8 sec.. Load from file. # startTime &lt;- Sys.time() # whatif.out.att.np &lt;- fciR::boot_est( # whatifdat, fciR::backdr_out_np, R = 250, conf = 0.95, outcome.name = &quot;Y&quot;, # exposure.name = &quot;A&quot;, confound.names = &quot;H&quot;, att = TRUE) # endTime &lt;- Sys.time() # print(endTime - startTime) a_file &lt;- file.path(dir_data, &quot;chap06_whatif_out_att_np.rds&quot;) # saveRDS(whatif.out.att.np, file = a_file) whatif.out.att.np &lt;- readRDS(file = a_file) Double What-if? Study doublewhatif.att &lt;- fciR::boot_est( doublewhatifdat, fciR::backdr_out_npr, R = 500, conf = 0.95, outcome.name = &quot;VL1&quot;, exposure.name = &quot;A&quot;, confound.names = &quot;AD0&quot;, interactions = list(c(&quot;A&quot;, &quot;AD0&quot;)), att = TRUE) doublewhatif.att &lt;- fciR::boot_est( doublewhatifdat, fciR::backdr_out_npr, R = 500, conf = 0.95, outcome.name = &quot;VL1&quot;, exposure.name = &quot;A&quot;, confound.names = &quot;VL0&quot;, interactions = list(c(&quot;A&quot;, &quot;VL0&quot;)), att = TRUE) 6.1.2 Standardization with a Parametric Outcome Model For a the parametric outcome model fciR::backdr_out() is used What-if? Study data(&quot;whatif2dat&quot;, package = &quot;fciR&quot;) whatif2.out &lt;- fciR::boot_est( whatif2dat, fciR::backdr_out, R = 100, conf = 0.95, outcome.name = &quot;vl4&quot;, exposure.name = &quot;A&quot;, confound.names = &quot;lvlcont0&quot;) and we compare with the authors comp &lt;- data.frame( name = c(&quot;EY0&quot;, &quot;EY1&quot;, &quot;RD&quot;, &quot;RR&quot;), auth = c(0.360, 0.300, -0.061, 0.831), est = whatif2.out$est[whatif2.out$name %in% c(&quot;EY0&quot;, &quot;EY1&quot;, &quot;RD&quot;, &quot;RR&quot;)] ) # comp stopifnot(sum(abs(comp$auth - comp$est)) &lt; 0.01) and the results are presented in table 6.1 General Social Survey data(&quot;gss&quot;, package = &quot;fciR&quot;) gssrcc &lt;- gss[, c(&quot;trump&quot;, &quot;gthsedu&quot;, &quot;magthsedu&quot;, &quot;white&quot;, &quot;female&quot;, &quot;gt65&quot;)] gssrcc &lt;- gssrcc[complete.cases(gssrcc), ] message(&quot;This takes about 15 sec.. Load from file.&quot;) ## This takes about 15 sec.. Load from file. # startTime &lt;- Sys.time() # gssrcc.out &lt;- boot_est(data = gssrcc, func = backdr_out, # R = 100, conf = 0.95, # outcome.name = &quot;trump&quot;, exposure.name = &quot;gthsedu&quot;, # confound.names = c(&quot;magthsedu&quot;, &quot;white&quot;, &quot;female&quot;, &quot;gt65&quot;)) # endTime &lt;- Sys.time() # print(endTime - startTime) a_file &lt;- file.path(dir_data, &quot;chap06_gssrcc_out.rds&quot;) # saveRDS(gssrcc.out, file = a_file) gssrcc.out &lt;- readRDS(file = a_file) # gssrcc.out and we compare with the authors comp &lt;- data.frame( name = c(&quot;EY0&quot;, &quot;EY1&quot;, &quot;RD&quot;, &quot;RR&quot;), auth = c(0.233, 0.271, 0.038, 1.164), est = gssrcc.out$est[gssrcc.out$name %in% c(&quot;EY0&quot;, &quot;EY1&quot;, &quot;RD&quot;, &quot;RR&quot;)] ) stopifnot(sum(abs(comp$auth - comp$est)) &lt; 0.01) and the results are presented in table 6.8 6.2 Standardization via Exposure Modeling The exposure model is also known as the propensity score, denoted \\(e(H)\\), as it is a function of \\(H\\). \\[ \\begin{align*} e(H) = (T \\mid H) = expit(\\alpha_0 + \\alpha_1 H_1 + \\ldots + \\alpha_k H_k) \\end{align*} \\] the proof of \\[ E(Y(1)) = E \\left( \\frac{TY}{e(H)} \\right) \\] is \\[ \\begin{align*} &amp;\\text{by definition of expectation} \\\\ E \\left( \\frac{t \\cdot y}{e(H)} \\right) &amp;= \\sum_{y,t,h} \\frac{TY}{e(H)} P(Y=y,T=t,H=h) \\\\ &amp;\\text{by multiplication rule} \\\\ &amp;= \\sum_{y,t,h} \\frac{t \\cdot y}{e(H)} P(Y=y \\mid T=t,H=h) P(T=t \\mid H=h) P(H=h) \\\\ &amp;\\text{because } T \\text{ is binary, and by definition of } e(H) \\text{ then } e(H) = P(T \\mid H) \\\\ &amp;= \\sum_{y,t,h} \\frac{t \\cdot y}{e(H)} P(Y=y \\mid T=t,H=h) e(H) P(H=h) \\\\ &amp;\\text{and when } T=0 \\text{ the summand is zero, therefore we are left with } T=1 \\\\ &amp;= \\sum_{y,h} \\frac{y}{e(H)} P(Y=y \\mid T=1,H=h) e(H) P(H=h) \\\\ &amp;\\text{we cancel the } e(H) \\text{ in numerator and denominator} \\\\ &amp;= \\sum_{y,h} y P(Y=y \\mid T=1,H=h) P(H=h) \\\\ &amp;\\text{by definition of conditional expectation} \\\\ &amp;= E_H (E(Y \\mid T=1, H)) \\\\ &amp;\\text{and by (6.2) which implies (6.1)} \\\\ &amp;= E(Y(1)) \\end{align*} \\] Examples Mortality Rates by Country See section 1.2.1 in chapter 1 for details on data_mortability_exp. data(&quot;mortality_long&quot;, package = &quot;fciR&quot;) mortdat &lt;- as.data.frame(mortality_long) Compute the standardized estimates using exposure modeling with fciR::backdr_exp_np mortdat.out &lt;- fciR::backdr_exp_bb(mortdat, outcome.name = &quot;Y&quot;, exposure.name = &quot;T&quot;, confound.names = &quot;H&quot;, weights = &quot;n&quot;) mortdat.out[c(&quot;EY0&quot;, &quot;EY1&quot;)] ## $EY0 ## [1] 0.007839904 ## ## $EY1 ## [1] 0.006995183 # verify with the author&#39;s stopifnot(abs(mortdat.out$EY0 - 0.0078399) &lt; 1e-6, abs(mortdat.out$EY1 - 0.0069952) &lt; 1e-6) summ &lt;- mort %&gt;% count(Y, `T`, H, name = &quot;n&quot;) %&gt;% mutate(freq = n / sum(n)) summ ## Y T H n freq ## 1 0 0 0 129433 0.7350806452 ## 2 0 0 1 12549 0.0712687415 ## 3 0 1 0 28154 0.1598932303 ## 4 0 1 1 4611 0.0261869605 ## 5 1 0 0 292 0.0016583371 ## 6 1 0 1 751 0.0042651068 ## 7 1 1 0 75 0.0004259428 ## 8 1 1 1 215 0.0012210359 stopifnot(sum(summ$freq) == 1) eH &lt;- summ %&gt;% group_by(`T`, H) %&gt;% summarize(n = sum(n)) %&gt;% group_by(H) %&gt;% mutate(prob = n / sum(n)) %&gt;% filter(`T` == 1) %&gt;% arrange(H) %&gt;% pull(prob) # eH stopifnot(all(eH &gt; .Machine$double.eps^0.5)) eH0 &lt;- eH[1] eH1 &lt;- eH[2] is_att &lt;- TRUE e0 &lt;- 1L if (is_att) { e0 &lt;- summ %&gt;% filter(`T` == 1) %&gt;% summarize(sum(freq)) %&gt;% pull() } # create the eH variable EY &lt;- summ %&gt;% mutate(eH = (1 - H) * eH0 + H * eH1) # compute the summand of the estimating equations if (!is_att) { EY &lt;- EY %&gt;% mutate(s = (1 - `T`) * Y / (1 - eH) + `T` * Y / eH) } else { EY &lt;- EY %&gt;% mutate(s = (1 - `T`) * Y * eH / (e0 * (1 - eH)) + `T` * Y / eH) # E(Y|T=1) is estimated as before (see very last paragraph of section 6.2.1) EYT &lt;- summ %&gt;% filter(`T` == 1) %&gt;% group_by(Y) %&gt;% summarize(n = sum(n)) %&gt;% mutate(prob = n / sum(n)) %&gt;% summarize(EYT = sum(Y * prob)) } # Estimate the value of the potential outcome EY &lt;- EY %&gt;% group_by(`T`) %&gt;% summarize(EY = sum(s * freq)) %&gt;% arrange(`T`) %&gt;% pull(EY) if (is_att) EY[2] &lt;- EYT EY ## [[1]] ## [1] 0.01016629 ## ## [[2]] ## [1] 0.008773257 6.2.1 Average Effect of Treatment on the Treated It can be proven that \\[ E(Y(0) \\mid T=1) = E \\left( \\frac{Y(1 - T) e(H)}{e_0(1 - e(H))} \\right), \\, e_0 = P(T=1) \\\\ \\] as follows \\[ \\begin{align*} &amp;\\text{by the rule of double expectation} \\\\ E(Y(0) \\mid T=1) &amp;= E_{H \\mid T=1} E(Y \\mid T=0, H) \\\\ &amp;\\text{by definition of expectation} \\\\ &amp;= E_{H \\mid T=1} \\left[ \\sum_{y} y P(Y=y \\mid T=0, H) \\right] \\\\ &amp;\\text{by definition of conditional expectation} \\\\ &amp;= \\sum_h \\left[ \\sum_{y} y P(Y=y \\mid T=0, H) \\right] P(H=h \\mid T=1) \\\\ &amp;\\text{by definition of conditional expectation we have that} \\\\ &amp;P(H=h \\mid T=1) = \\frac{P(T=1 \\mid H=h) P(H=h)}{P(T=1)} \\\\ &amp;\\text{therefore} \\\\ E(Y(0) \\mid T=1) &amp;= \\sum_{y,h} y P(Y=y \\mid T=0, H=h) \\frac{P(T=1 \\mid H=h) P(H=h)}{P(T=1)} \\\\ &amp;\\text{rearranging terms} \\\\ &amp;= \\sum_{y,h} y \\frac{P(T=1 \\mid H=h)}{P(T=1)} \\left[ P(Y=y \\mid T=0, H=h)P(H=h) \\right] \\\\ &amp;\\text{and multiply by } 1 = \\frac{P(T=0 \\mid H=h)}{P(T=0 \\mid H=h)} \\\\ &amp;= \\sum_{y,h} y \\frac{P(T=1 \\mid H=h)}{P(T=1)} \\left[ \\frac{P(Y=y \\mid T=0, H=h)P(T=0 \\mid H=h)P(H=h)}{P(T=0 \\mid H=h)} \\right] \\\\ &amp;\\text{rearranging the terms again} \\\\ &amp;= \\sum_{y,h} y \\frac{P(T=1 \\mid H=h)}{P(T=1)P(T=0 \\mid H=h)} \\left[ P(Y=y \\mid T=0, H=h)P(T=0 \\mid H=h)P(H=h) \\right] \\\\ &amp;\\text{using the multiplication rule} \\\\ &amp;= \\sum_{y,h} y \\frac{P(T=1 \\mid H=h)}{P(T=1)P(T=0 \\mid H=h)} P(Y=y, T=0, H=h) \\\\ &amp;\\text{ and since } e(h) = P(T=1 \\mid H=h) \\text{ and } e_0 = P(T=1) \\\\ &amp;= \\sum_{y,h} y \\cdot \\frac{e(h)}{e_0 (1 - e(h))} \\cdot P(Y=y, T=0, H=h) \\\\ &amp;\\text{ and since } \\sum_t (1-t) P(Y=y, T=t, H=h) = P(Y=y, T=0, H=h) \\\\ &amp;= \\sum_{y,h} y \\cdot \\frac{e(h)}{e_0 (1 - e(h))} \\cdot \\sum_t (1-t) P(Y=y, T=t, H=h) \\\\ &amp;= \\sum_{y,h, t} y \\cdot (1-t) \\cdot \\frac{e(h)}{e_0 (1 - e(h))} \\cdot P(Y=y, T=t, H=h) \\\\ &amp;\\text{and by definition of expectation} \\\\ &amp;= E \\left[ Y \\cdot (1-T) \\cdot \\frac{e(H)}{e_0 (1 - e(H))} \\right] \\end{align*} \\] See previous section for calculation with mortality data for the function with the flag is_att = TRUE mortdat.out[[&quot;EY0T1&quot;]] ## [1] 0.01017592 stopifnot(abs(mortdat.out$EY0T1 - 0.010176) &lt; 1e-6) 6.2.2 Standardization with a Parametric Exposure Model The function fciR::backdr_exp() is used to standardized with a parametric exposure model and the glm fit. It is the main function used in the chapter. Alternatively the standardization could be done with geeglm from the geepack package. For those focused primarily on the risk difference. See the explanation on section 6.2.2 on why geeglm is not really good for the risk ratio. The function is called exp in the book. We rename it fciR::backdr_exp() to be more informative and avoid mix up with the much-used base R function exp. What-if? Study First we do it using the glm fit whatif2.exp &lt;- boot_est(data = whatif2dat, func = backdr_exp, R = 250, conf = 0.95, outcome.name = &quot;vl4&quot;, exposure.name = &quot;A&quot;, confound.names = c(&quot;lvlcont0&quot;)) # whatif2.exp and compare with the authors comp &lt;- data.frame( name = c(&quot;EY0&quot;, &quot;EY1&quot;, &quot;RD&quot;, &quot;RR&quot;), auth = c(0.36, 0.30, -0.06, 0.834), est = whatif2.exp$est[whatif2.exp$name %in% c(&quot;EY0&quot;, &quot;EY1&quot;, &quot;RD&quot;, &quot;RR&quot;)]) stopifnot(sum(abs(comp$auth - comp$est)) &lt; 0.01) and the results are presented in table 6.9 then we use the geeglm from the geepack package fit for risk difference message(&quot;This takes about 6 sec.. Load from file.&quot;) ## This takes about 6 sec.. Load from file. # startTime &lt;- Sys.time() # whatif2.expgee &lt;- boot_est(data = whatif2dat, func = backdr_exp_gee, # R = 250, conf = 0.95, # outcome.name = &quot;vl4&quot;, exposure.name = &quot;A&quot;, # confound.names = &quot;lvlcont0&quot;) # endTime &lt;- Sys.time() # print(endTime - startTime) a_file &lt;- file.path(dir_data, &quot;chap06_whatif2gee.rds&quot;) # saveRDS(whatif2.expgee, file = a_file) whatif2.expgee &lt;- readRDS(a_file) # we don&#39;t use the risk ratio measures with this function whatif2.expgee &lt;- whatif2.expgee[!(whatif2.expgee$name %in% c(&quot;RR*&quot;, &quot;OR&quot;)), ] # whatif2.expgee and the results are presented in table 6.9 html { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif; } #ucreoxvmws .gt_table { display: table; border-collapse: collapse; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #ucreoxvmws .gt_heading { background-color: #DCDCDC; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #ucreoxvmws .gt_title { color: #333333; font-size: 125%; font-weight: bold; padding-top: 4px; padding-bottom: 4px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #ucreoxvmws .gt_subtitle { color: #333333; font-size: 85%; font-weight: bold; padding-top: 0; padding-bottom: 6px; border-top-color: #FFFFFF; border-top-width: 0; } #ucreoxvmws .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #ucreoxvmws .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #ucreoxvmws .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: bold; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #ucreoxvmws .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: bold; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #ucreoxvmws .gt_column_spanner_outer:first-child { padding-left: 0; } #ucreoxvmws .gt_column_spanner_outer:last-child { padding-right: 0; } #ucreoxvmws .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; } #ucreoxvmws .gt_group_heading { padding: 8px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; } #ucreoxvmws .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #ucreoxvmws .gt_from_md > :first-child { margin-top: 0; } #ucreoxvmws .gt_from_md > :last-child { margin-bottom: 0; } #ucreoxvmws .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #ucreoxvmws .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 12px; } #ucreoxvmws .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #ucreoxvmws .gt_first_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; } #ucreoxvmws .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #ucreoxvmws .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #ucreoxvmws .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #ucreoxvmws .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #ucreoxvmws .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #ucreoxvmws .gt_footnote { margin: 0px; font-size: 90%; padding: 4px; } #ucreoxvmws .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #ucreoxvmws .gt_sourcenote { font-size: 90%; padding: 4px; } #ucreoxvmws .gt_left { text-align: left; } #ucreoxvmws .gt_center { text-align: center; } #ucreoxvmws .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #ucreoxvmws .gt_font_normal { font-weight: normal; } #ucreoxvmws .gt_font_bold { font-weight: bold; } #ucreoxvmws .gt_font_italic { font-style: italic; } #ucreoxvmws .gt_super { font-size: 65%; } #ucreoxvmws .gt_footnote_marks { font-style: italic; font-weight: normal; font-size: 65%; } Table 6.9 geeglm What-If StudyExposure-model Standardization using geeglm wtih H = lvlcont0 Measure Estimate CI1 EY0 0.360 (0.236, 0.472) EY1 0.300 (0.219, 0.388) RD -0.060 (-0.179, 0.079) RR 0.834 (0.585, 1.252) Fundamentals of Causal Inference, Babette A. Brumback, 2022 1 95% confidence interval General Social Survey The gssrcc is defined in section 6.1.2 above. It is the gss data with complete cases only. The standexp function on page 119-120 of section 6.2.2 is not needed anymore as standexp was created with parameters in the previous section. We just need to run it as follows message(&quot;This takes about 10 sec. Load from file.&quot;) ## This takes about 10 sec. Load from file. # startTime &lt;- Sys.time() # gssrcc.exp &lt;- boot_est(data = gssrcc, func = backdr_exp, # R = 250, conf = 0.95, # outcome.name = &quot;trump&quot;, exposure.name = &quot;gthsedu&quot;, # confound.names = c(&quot;magthsedu&quot;, &quot;white&quot;, &quot;female&quot;, &quot;gt65&quot;)) # endTime &lt;- Sys.time() # print(endTime - startTime) a_file &lt;- file.path(dir_data, &quot;chap06_gssrcc_exp.rds&quot;) # saveRDS(gssrcc.exp, file = a_file) gssrcc.exp &lt;- readRDS(file = a_file) # gssrcc.exp and compare with the authors comp &lt;- data.frame( name = c(&quot;EY0&quot;, &quot;EY1&quot;, &quot;RD&quot;, &quot;RR&quot;), auth = c(0.231, 0.272, 0.041, 1.176), est = gssrcc.exp$est[gssrcc.exp$name %in% c(&quot;EY0&quot;, &quot;EY1&quot;, &quot;RD&quot;, &quot;RR&quot;)]) stopifnot(sum(abs(comp$auth - comp$est)) &lt; 0.01) and the results are presented in table 6.9 6.3 Doubly Robust Standardization The function backdr_dr() does a doubly robust standardization. It is not in the text but is actually used for the exercise. It is very similar to badstanddr. The function badstanddr is replaced by backdr_dr_bad, used for doubly robust standardization with a misspecified outcome model. and using the What-if Study we obtain whatif2.bad &lt;- boot_est(data = whatif2dat, func = fciR::backdr_dr_bad, R = 100, conf = 0.95, outcome.name = &quot;vl4&quot;, exposure.name = &quot;A&quot;, confound.names = &quot;lvlcont0&quot;) # whatif2.bad and compare with the authors comp &lt;- data.frame( name = c(&quot;EY0&quot;, &quot;EY1&quot;, &quot;RD&quot;, &quot;RR&quot;), auth = c(0.362, 0.300, -0.062, 0.830), est = whatif2.bad$est[whatif2.bad$name %in% c(&quot;EY0&quot;, &quot;EY1&quot;, &quot;RD&quot;, &quot;RR&quot;)]) stopifnot(sum(abs(comp$auth - comp$est)) &lt; 0.01) and the results are presented in table 6.9 6.3.1 Doubly Robust Standardization Simulation 6.3.1.1 With simdr The simulation of doubly robust standardization discussed at the end of section 6.3 in p. 126 to 130 and found in simdr is analyzed in an appendix at Doubly Robust Simulation. The results obtained by Brumback are close enough to what we have below. Here is a tableau of her results ## Warning in data(fciR::fci_tbl_06_13): data set &#39;fciR::fci_tbl_06_13&#39; not found html { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif; } #aaqqcvhnty .gt_table { display: table; border-collapse: collapse; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #aaqqcvhnty .gt_heading { background-color: #DCDCDC; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #aaqqcvhnty .gt_title { color: #333333; font-size: 125%; font-weight: bold; padding-top: 4px; padding-bottom: 4px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #aaqqcvhnty .gt_subtitle { color: #333333; font-size: 85%; font-weight: bold; padding-top: 0; padding-bottom: 6px; border-top-color: #FFFFFF; border-top-width: 0; } #aaqqcvhnty .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #aaqqcvhnty .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #aaqqcvhnty .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: bold; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #aaqqcvhnty .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: bold; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #aaqqcvhnty .gt_column_spanner_outer:first-child { padding-left: 0; } #aaqqcvhnty .gt_column_spanner_outer:last-child { padding-right: 0; } #aaqqcvhnty .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; } #aaqqcvhnty .gt_group_heading { padding: 8px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; } #aaqqcvhnty .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #aaqqcvhnty .gt_from_md > :first-child { margin-top: 0; } #aaqqcvhnty .gt_from_md > :last-child { margin-bottom: 0; } #aaqqcvhnty .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #aaqqcvhnty .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 12px; } #aaqqcvhnty .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #aaqqcvhnty .gt_first_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; } #aaqqcvhnty .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #aaqqcvhnty .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #aaqqcvhnty .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #aaqqcvhnty .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #aaqqcvhnty .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #aaqqcvhnty .gt_footnote { margin: 0px; font-size: 90%; padding: 4px; } #aaqqcvhnty .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #aaqqcvhnty .gt_sourcenote { font-size: 90%; padding: 4px; } #aaqqcvhnty .gt_left { text-align: left; } #aaqqcvhnty .gt_center { text-align: center; } #aaqqcvhnty .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #aaqqcvhnty .gt_font_normal { font-weight: normal; } #aaqqcvhnty .gt_font_bold { font-weight: bold; } #aaqqcvhnty .gt_font_italic { font-style: italic; } #aaqqcvhnty .gt_super { font-size: 65%; } #aaqqcvhnty .gt_footnote_marks { font-style: italic; font-weight: normal; font-size: 65%; } Table 6.13 and 6.14 Sampling Distribution from SimulationInvestigating Small-Sample RobustnessTrue E(Y(0))=0.01, True E(Y(1))=0.02 estimator description ss=40 ss=100 mean sd pval mean sd pval EYT0 Unadjusted 0.0076 0.0015 0.00 0.0079 0.0016 0.00 EYT1 Unadjusted 0.0042 0.0012 0.00 0.0038 0.0012 0.00 EY0exp Linear Exposure 0.0100 0.0021 0.92 0.0100 0.0020 0.61 EY1exp Linear Exposure 0.0195 0.0127 0.19 0.0196 0.0562 0.81 EY0exp2 Logistic Exposure 0.0101 0.0021 0.42 0.0100 0.0020 0.73 EY1exp2 Logistic Exposure 0.0204 0.0064 0.07 0.0200 0.0068 0.96 EY0out Overspecified Outcome 0.0100 0.0021 0.79 0.0100 0.0020 0.74 EY1out Overspecified Outcome 0.0200 0.0066 0.84 0.0200 0.0069 0.74 EY0dr Doubly Robust 0.0100 0.0021 0.82 0.0100 0.0020 0.72 EY1dr Doubly Robust 0.0197 0.0106 0.37 0.0290 0.1891 0.14 Fundamentals of Causal Inference, Babette A. Brumback, 2022 6.3.1.2 With mc_standdr We perform the simulation using a Monte Carlo simulation called mc_standdr. The script is in the appendix at mc_standdr. We use a sample size of only 1000 as in the book. nrep &lt;- 1000 So here the simulation with \\(ss \\in \\{40, 100\\}\\) message(&quot;This takes about 8 min. Load from file.&quot;) ## This takes about 8 min. Load from file. # startTime &lt;- Sys.time() # mc.out &lt;- fciR::mc_standdr(ss = c(40, 100), nrep = nrep) # endTime &lt;- Sys.time() # print(endTime - startTime) a_file &lt;- file.path(dir_data, &quot;chap06_mc_out.rds&quot;) mc.out &lt;- readRDS(file = a_file) # saveRDS(mc.out, file = a_file) and we compute the p-values mc.out &lt;- mc.out %&gt;% mutate(`T` = ifelse(grepl(pattern = &quot;0&quot;, estimator), 0, 1), h0 = ifelse(`T` == 0, 0.01, 0.02), sdp = sd / sqrt(n), z = abs((mean - h0) / sdp), pval = 2 * (1 - pnorm(z))) %&gt;% select(-sdp, -z) # mc.out and show the results in a table html { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif; } #agjtxedchv .gt_table { display: table; border-collapse: collapse; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #agjtxedchv .gt_heading { background-color: #DCDCDC; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #agjtxedchv .gt_title { color: #333333; font-size: 125%; font-weight: bold; padding-top: 4px; padding-bottom: 4px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #agjtxedchv .gt_subtitle { color: #333333; font-size: 85%; font-weight: bold; padding-top: 0; padding-bottom: 6px; border-top-color: #FFFFFF; border-top-width: 0; } #agjtxedchv .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #agjtxedchv .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #agjtxedchv .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: bold; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #agjtxedchv .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: bold; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #agjtxedchv .gt_column_spanner_outer:first-child { padding-left: 0; } #agjtxedchv .gt_column_spanner_outer:last-child { padding-right: 0; } #agjtxedchv .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; } #agjtxedchv .gt_group_heading { padding: 8px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; } #agjtxedchv .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #agjtxedchv .gt_from_md > :first-child { margin-top: 0; } #agjtxedchv .gt_from_md > :last-child { margin-bottom: 0; } #agjtxedchv .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #agjtxedchv .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 12px; } #agjtxedchv .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #agjtxedchv .gt_first_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; } #agjtxedchv .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #agjtxedchv .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #agjtxedchv .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #agjtxedchv .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #agjtxedchv .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #agjtxedchv .gt_footnote { margin: 0px; font-size: 90%; padding: 4px; } #agjtxedchv .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #agjtxedchv .gt_sourcenote { font-size: 90%; padding: 4px; } #agjtxedchv .gt_left { text-align: left; } #agjtxedchv .gt_center { text-align: center; } #agjtxedchv .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #agjtxedchv .gt_font_normal { font-weight: normal; } #agjtxedchv .gt_font_bold { font-weight: bold; } #agjtxedchv .gt_font_italic { font-style: italic; } #agjtxedchv .gt_super { font-size: 65%; } #agjtxedchv .gt_footnote_marks { font-style: italic; font-weight: normal; font-size: 65%; } Table 6.13 and 6.14 (by FL) Sampling Distribution from SimulationInvestigating Small-Sample RobustnessTrue E(Y(0))=0.01, True E(Y(1))=0.02 estimator description ss=40 ss=100 mean sd pval mean sd pval EYT0 Unadjusted 0.0076 0.0016 0.00 0.0079 0.0016 0.00 EYT1 Unadjusted 0.0042 0.0011 0.00 0.0038 0.0011 0.00 EY0exp Linear Exposure 0.0100 0.0021 0.65 0.0099 0.0021 0.03 EY1exp Linear Exposure 0.0198 0.0072 0.45 0.0197 0.0173 0.63 EY0exp2 Logistic Exposure 0.0101 0.0021 0.25 0.0099 0.0021 0.06 EY1exp2 Logistic Exposure 0.0203 0.0063 0.15 0.0199 0.0066 0.51 EY0out Overspecified Outcome 0.0100 0.0021 0.52 0.0099 0.0021 0.04 EY1out Overspecified Outcome 0.0199 0.0065 0.60 0.0198 0.0068 0.44 EY0dr Doubly Robust 0.0100 0.0021 0.55 0.0099 0.0021 0.04 EY1dr Doubly Robust 0.0204 0.0145 0.36 0.0252 0.0982 0.09 Fundamentals of Causal Inference, Babette A. Brumback, 2022 6.3.1.3 Plotting the Monte Carlo Simulation We will not reiterate the comments from Brumback as the results in the tableau just above confirm them. A plot can however illustrate Brumbacks main points. This ones shows the estimates mean with their 5% and 95% quantiles from the simulation. 6.4 Exercises The exercises are located in a separate project. "],["did.html", "Chapter 7 Difference-in-Differences Estimators 7.1 Difference-in-Differences (DiD) Estimators 7.2 Comparison with Standardization", " Chapter 7 Difference-in-Differences Estimators library(dplyr) library(fciR) options(dplyr.summarise.inform = FALSE) 7.1 Difference-in-Differences (DiD) Estimators 7.1.1 DiD Estimator with a Linear Model The method relies on consistency as well as assumption A1: \\[ \\begin{align*} &amp;E(Y_1(0) \\mid A=1) - E(Y_1(0) \\mid A=1) = \\\\ &amp;E(Y_0(0) \\mid A=1) - E(Y_0(0) \\mid A=1) \\end{align*} \\] That assumption is interpreted as : If assume that no treatment was applied in year 1 (nothing happened in year 1) than we have the same results as in the base year. also called additive equi-confounding []. The target of estimation is the linear ATT presented in chapter 6 as a risk difference \\[ \\text{Linear ATT:} \\: E(Y_1(1) - Y_1(0) \\mid A=1) \\] which is interpreted as *what is the the average difference between \\(Y_1(1)\\) and \\(Y_1(0)\\) if they all treated. For the example of the banks NIM, what is the average difference between the banks NIM in NIRP ad non-NIRP economy assuming they are all subjected to the NIRP policy, that is wihout the impact of the NIRP policy. and we have \\[ \\begin{align*} &amp; E(Y_1(1) - Y_1(0)) \\mid A=1) = \\\\ &amp; E(Y_1(1) \\mid A=1) - E(Y_1(0) \\mid A=1) = \\\\ &amp; [E(Y_1(1) \\mid A=1) - E(Y_1(0) \\mid A=1)] - [E(Y_1(0) \\mid A=0) - E(Y_1(0) \\mid A=0)] = \\\\ &amp; [E(Y_1(1) \\mid A=1) - E(Y_1(0) \\mid A=0)] - [E(Y_1(0) \\mid A=1) - E(Y_1(0) \\mid A=0)] = \\\\ &amp;\\text{consistency assumption} \\\\ &amp; [E(Y_1 \\mid A=1) - E(Y_1 \\mid A=0)] - [E(Y_1(0) \\mid A=1) - E(Y_1(0) \\mid A=0)] = \\\\ &amp;\\text{assumption A1, additive equi-confounding} \\\\ &amp;\\text{i.e. assuming that if nothing happens in year 1, then we can use the results of year 0} \\\\ &amp; [E(Y_1 \\mid A=1) - E(Y_1 \\mid A=0)] - [E(Y_0 \\mid A=1) - E(Y_0 \\mid A=0)] \\end{align*} \\] we can therefore estimate the linear ATT via the difference in differences of averages \\[ \\begin{align*} &amp;[\\hat{E}(Y_1 \\mid A=1) - \\hat{E}(Y_1 \\mid A=0)] - [\\hat{E}(Y_0 \\mid A=1) - \\hat{E}(Y_0 \\mid A=0)]= \\\\ &amp;[\\hat{E}(Y_1 \\mid A=1) - \\hat{E}(Y_0 \\mid A=1)] - [\\hat{E}(Y_1 \\mid A=0) - \\hat{E}(Y_0 \\mid A=0)]= \\\\ &amp;[\\hat{E}(Y_1 - Y_0 \\mid A=1)] - [\\hat{E}(Y_1 - Y_0 \\mid A=0)] \\end{align*} \\] We can also compute the DiD via the linear model \\[ E(Y_t \\mid A) = \\alpha_0 + \\alpha_1 t + \\alpha_2 A + \\beta A * t \\] and therefore \\[ \\begin{align*} \\beta &amp;= [E(Y_1 \\mid A=1) - E(Y_0 \\mid A=1)] - [E(Y_1 \\mid A=0) - E(Y_0 \\mid A=0)] \\\\ &amp;= (\\alpha_0 + \\alpha_1 + \\alpha_2 + \\beta) - (\\alpha_0 + \\alpha_2) - ((\\alpha_0 + \\alpha_2) - (\\alpha_0)) \\end{align*} \\] As we can estimate \\(E(Y(1) \\mid A=1)\\) directly via \\(E(Y_1 \\mid A=1)\\), we can also recover \\(E(Y(0) \\mid A=1)\\) via \\(E(Y_1 \\mid A=1) - \\beta\\) because from above we have \\[ \\begin{align*} \\beta &amp;= E(Y_1(1) - Y_1(0)) \\mid A=1) \\\\ &amp;= E(Y_1(1) \\mid A=1) - E(Y_1(0) \\mid A=1) \\\\ &amp;= E(Y_1 \\mid A=1) - E(Y_1(0) \\mid A=1) \\\\ &amp;\\therefore \\\\ E(Y_1(0) \\mid A=1)&amp; = E(Y_1 \\mid A=1) - \\beta \\end{align*} \\] 7.1.2 DiD Estimator with a Loglinear Model The method relies on consistency as well as assumption A2: \\[ \\begin{align*} \\frac{E(Y_1(0) \\mid A=1)}{E(Y_1(0) \\mid A=1)} = \\frac{E(Y_0(0) \\mid A=1)}{E(Y_0(0) \\mid A=1)} \\end{align*} \\] 7.1.3 DiD Estimator with a Logistic Model The method relies on consistency as well as assumption A3: \\[ \\begin{align*} logit(E(Y_1(0) \\mid A=1)) - logit(E(Y_1(0) \\mid A=1)) = logit(E(Y_0(0) \\mid A=1)) - logit(E(Y_0(0) \\mid A=1)) \\end{align*} \\] 7.2 Comparison with Standardization The functions used for DID estimations are fciR::did_linear(), fciR::did_loglinear and fciR::logistic. 7.2.1 doublewhatifdat The DiD estimator with the linear model dwhatif.lindid &lt;- fciR::boot_est( doublewhatifdat, fciR::did_linear, R = 100, conf = 0.95, outcome.name = &quot;VL1&quot;, exposure.name = &quot;A&quot;, confound.names = &quot;VL0&quot;) # dwhatif.lindid The DiD estimator with the loglinear model dwhatif.loglindid &lt;- fciR::boot_est( doublewhatifdat, fciR::did_loglinear, R = 100, conf = 0.95, outcome.name = &quot;VL1&quot;, exposure.name = &quot;A&quot;, confound.names = &quot;VL0&quot;) # dwhatif.loglindid The DiD estimator with the logistic model dwhatif.logisticdid &lt;- fciR::boot_est( doublewhatifdat, fciR::did_logistic, R = 100, conf = 0.95, outcome.name = &quot;VL1&quot;, exposure.name = &quot;A&quot;, confound.names = &quot;VL0&quot;) # dwhatif.logisticdid verify the results data(&quot;fci_tbl_07_02&quot;, package = &quot;fciR&quot;) bb_dwhatif &lt;- fci_tbl_07_02 # bb_dwhatif gt_measures_rowgrp( bb_dwhatif, rowgroup = &quot;name&quot;, rowname = &quot;method&quot;, conf = 0.95, title = &quot;Table 7.2&quot;, subtitle = &quot;Double What-If Study&lt;br&gt;Difference-in-Differences Estimation of the ATT&quot; ) html { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif; } #gclqyxwrjf .gt_table { display: table; border-collapse: collapse; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #gclqyxwrjf .gt_heading { background-color: #DCDCDC; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #gclqyxwrjf .gt_title { color: #333333; font-size: 125%; font-weight: bold; padding-top: 4px; padding-bottom: 4px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #gclqyxwrjf .gt_subtitle { color: #333333; font-size: 85%; font-weight: bold; padding-top: 0; padding-bottom: 6px; border-top-color: #FFFFFF; border-top-width: 0; } #gclqyxwrjf .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #gclqyxwrjf .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #gclqyxwrjf .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: bold; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #gclqyxwrjf .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: bold; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #gclqyxwrjf .gt_column_spanner_outer:first-child { padding-left: 0; } #gclqyxwrjf .gt_column_spanner_outer:last-child { padding-right: 0; } #gclqyxwrjf .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; } #gclqyxwrjf .gt_group_heading { padding: 8px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: bold; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; } #gclqyxwrjf .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: bold; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #gclqyxwrjf .gt_from_md > :first-child { margin-top: 0; } #gclqyxwrjf .gt_from_md > :last-child { margin-bottom: 0; } #gclqyxwrjf .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #gclqyxwrjf .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 12px; } #gclqyxwrjf .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #gclqyxwrjf .gt_first_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; } #gclqyxwrjf .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #gclqyxwrjf .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #gclqyxwrjf .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #gclqyxwrjf .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #gclqyxwrjf .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #gclqyxwrjf .gt_footnote { margin: 0px; font-size: 90%; padding: 4px; } #gclqyxwrjf .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #gclqyxwrjf .gt_sourcenote { font-size: 90%; padding: 4px; } #gclqyxwrjf .gt_left { text-align: left; } #gclqyxwrjf .gt_center { text-align: center; } #gclqyxwrjf .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #gclqyxwrjf .gt_font_normal { font-weight: normal; } #gclqyxwrjf .gt_font_bold { font-weight: bold; } #gclqyxwrjf .gt_font_italic { font-style: italic; } #gclqyxwrjf .gt_super { font-size: 65%; } #gclqyxwrjf .gt_footnote_marks { font-style: italic; font-weight: normal; font-size: 65%; } Table 7.2 Double What-If StudyDifference-in-Differences Estimation of the ATT Truth Estimate CI1 E(VL1|A=1) All 0.199 0.231 (0.179, 0.282) EY0A1 Linear 0.559 0.586 (0.508, 0.664) Loglinear 0.559 0.577 (0.498, 0.656) Logistic 0.559 0.592 (0.513, 0.671) RD Linear -0.360 -0.355 (-0.441, -0.27) Loglinear -0.360 -0.346 (-0.431, -0.262) Logistic -0.360 -0.362 (-0.447, -0.276) RR Linear 0.356 0.394 (0.309, 0.5) Loglinear 0.356 0.400 (0.315, 0.508) Logistic 0.356 0.390 (0.306, 0.496) OR Linear 0.196 0.212 (0.142, 0.315) Loglinear 0.196 0.220 (0.149, 0.325) Logistic 0.196 0.206 (0.139, 0.307) Fundamentals of Causal Inference, Babette A. Brumback, 2022 1 95% confidence interval and the results using the fciR package are identical. tbl_7.2 &lt;- rbind( data.frame( method = &quot;Linear&quot;, dwhatif.lindid), data.frame( method = &quot;Loglinear&quot;, dwhatif.loglindid), data.frame( method = &quot;Logistic&quot;, dwhatif.logisticdid)) gt_measures_rowgrp(tbl_7.2, rowgroup = &quot;name&quot;, rowname = &quot;method&quot;, conf = 0.95, title = &quot;Table 7.2&lt;em&gt;(by FL)&lt;/em&gt;&quot;, subtitle = &quot;Double What-If Study&lt;br&gt;Difference-in-Differences Estimation of the ATT&quot; ) html { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif; } #fukoeyernj .gt_table { display: table; border-collapse: collapse; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #fukoeyernj .gt_heading { background-color: #DCDCDC; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #fukoeyernj .gt_title { color: #333333; font-size: 125%; font-weight: bold; padding-top: 4px; padding-bottom: 4px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #fukoeyernj .gt_subtitle { color: #333333; font-size: 85%; font-weight: bold; padding-top: 0; padding-bottom: 6px; border-top-color: #FFFFFF; border-top-width: 0; } #fukoeyernj .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #fukoeyernj .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #fukoeyernj .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: bold; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #fukoeyernj .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: bold; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #fukoeyernj .gt_column_spanner_outer:first-child { padding-left: 0; } #fukoeyernj .gt_column_spanner_outer:last-child { padding-right: 0; } #fukoeyernj .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; } #fukoeyernj .gt_group_heading { padding: 8px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: bold; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; } #fukoeyernj .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: bold; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #fukoeyernj .gt_from_md > :first-child { margin-top: 0; } #fukoeyernj .gt_from_md > :last-child { margin-bottom: 0; } #fukoeyernj .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #fukoeyernj .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 12px; } #fukoeyernj .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #fukoeyernj .gt_first_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; } #fukoeyernj .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #fukoeyernj .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #fukoeyernj .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #fukoeyernj .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #fukoeyernj .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #fukoeyernj .gt_footnote { margin: 0px; font-size: 90%; padding: 4px; } #fukoeyernj .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #fukoeyernj .gt_sourcenote { font-size: 90%; padding: 4px; } #fukoeyernj .gt_left { text-align: left; } #fukoeyernj .gt_center { text-align: center; } #fukoeyernj .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #fukoeyernj .gt_font_normal { font-weight: normal; } #fukoeyernj .gt_font_bold { font-weight: bold; } #fukoeyernj .gt_font_italic { font-style: italic; } #fukoeyernj .gt_super { font-size: 65%; } #fukoeyernj .gt_footnote_marks { font-style: italic; font-weight: normal; font-size: 65%; } Table 7.2(by FL) Double What-If StudyDifference-in-Differences Estimation of the ATT Estimate CI1 EY0A1 Linear 0.586 (0.493, 0.66) Loglinear 0.577 (0.504, 0.654) Logistic 0.592 (0.516, 0.675) EY1 Linear 0.231 (0.17, 0.288) Loglinear 0.231 (0.179, 0.284) Logistic 0.231 (0.183, 0.271) RD Linear -0.355 (-0.431, -0.264) Loglinear -0.346 (-0.426, -0.27) Logistic -0.362 (-0.453, -0.284) RR Linear 0.394 (0.314, 0.51) Loglinear 0.400 (0.318, 0.505) Logistic 0.390 (0.308, 0.474) RR* Linear 0.538 (0.453, 0.673) Loglinear 0.550 (0.463, 0.652) Logistic 0.530 (0.433, 0.638) OR Linear 0.212 (0.15, 0.325) Loglinear 0.220 (0.153, 0.317) Logistic 0.206 (0.137, 0.294) Fundamentals of Causal Inference, Babette A. Brumback, 2022 1 95% confidence interval fciR::ggp_measures_groups(tbl_7.2, title = &quot;Table 7.2&quot;, subtitle = &quot;Double What-If Study\\nDifference-in-Differences Estimation of the ATT&quot;) "],["frontdoor.html", "Chapter 8 Front-Door Method 8.1 Motivation 8.2 Theory and Method 8.3 Simulated Example", " Chapter 8 Front-Door Method library(dplyr) library(ggdag) library(patchwork) library(ggplot2) library(fciR) options(dplyr.summarise.inform = FALSE) 8.1 Motivation scm_8.1 &lt;- list() scm_8.1 &lt;- within(scm_8.1, { coords &lt;- list( x = c(A = 1, S = 2, U = 2, Y = 3), y = c(A = 1, S = 1, U = 2, Y = 1)) dag &lt;- dagify( A ~ U, S ~ A, Y ~ S + U, coords = coords) plot &lt;- fciR::ggp_dag(dag) }) Figure 8.1: Front-door Causal DAG When \\(S\\) is a surrogate marker \\[ \\begin{align*} &amp;\\text{by double expectation rule} \\\\ E(Y \\mid A) &amp;= E_{S \\mid A}(E(Y \\mid A)) \\\\ &amp;\\text{by conditional expectation} \\\\ &amp;= \\sum_s E(Y \\mid S=s, A) P(S=s \\mid A) \\\\ &amp;\\text{because } Y \\perp\\!\\!\\!\\perp A \\mid S \\\\ &amp;= \\sum_s E(Y \\mid S=s) P(S=s \\mid A) \\\\ &amp;\\text{since there are no confounder for the effect of A on Y} \\\\ E(Y(a)) = E(Y \\mid A=a) &amp;= \\sum_s E(Y \\mid S=s) P(S=s \\mid A=a) \\end{align*} \\] 8.2 Theory and Method Using (8.1) from above \\[ \\begin{align*} E(Y(a)) = E(Y \\mid A=a) &amp;= \\sum_s E(Y \\mid S=s) P(S=s \\mid A=a) \\\\ &amp;\\text{and with backdoor standardization we have that} \\\\ &amp;E(Y \\mid S=s) = \\sum_{a^\\prime} E(Y \\mid S=s, A=a^\\prime)P(A = a^\\prime) \\\\ \\therefore \\\\ E(Y(a)) = E(Y \\mid A=a) &amp;= \\sum_s P(S=s \\mid A=a) \\left[ \\sum_{a^\\prime} E(Y \\mid S=s, A=a^\\prime)P(A = a^\\prime) \\right] \\\\ \\end{align*} \\] 8.3 Simulated Example sim1 &lt;- function(n = 1e4, seed = 555) { set.seed(seed) # Generate the potential outcome Y(.,0) and Y(.,1) Ydot0 &lt;- rbinom(n, size = 1, prob = 0.05) Ydot1 &lt;- rbinom(n, size = 1, prob = 0.2) # let A depend on Y(.,1) probA &lt;- (1 - Ydot1) * 0.1 + Ydot1 * 0.8 A &lt;- rbinom(n, size = 1, prob = probA) # Generate the potential outcome S(0) and S(1) S0 &lt;- rbinom(n, size = 1, prob = 0.05) S1 &lt;- rbinom(n, size = 1, prob = 0.9) # S is a function of S0, S1 and A S &lt;- (1 - A) * S0 + A * S1 # Y is a function of Y(., 0) and Y(., 1) and S Y &lt;- (1 - S) * Ydot0 + S * Ydot1 data.frame(cbind(A, S, Y, Ydot0, Ydot1)) } sim1_df &lt;- sim1() sim1.front &lt;- fciR::frontdr_np(sim1_df, outcome.name = &quot;Y&quot;, exposure.name = &quot;A&quot;, surrogate.name = &quot;S&quot;) sim1.front ## EY0 EY1 RD RR RR* OR ## 0.05584704 0.18536722 0.12952018 3.31919505 1.15899210 3.84692084 and we can estimates the confidence intervals using the usual bootstrapping. "],["errata.html", "A Errata A.1 Preface A.2 Chapter 1 A.3 Chapter 2 A.4 Chapter 3 A.5 Chapter 4 A.6 Chapter 5 A.7 Chapter 6 A.8 Chapter 7 A.9 Chapter 8", " A Errata A.1 Preface page xi, last word of first paragraph is standaridzation, s/b standardization A.2 Chapter 1 A.2.1 Section 1.2.3.2, p. 11 The sentence of the 6th line on top of the page is We simulated the data according to the hyothetical Should be hypothetical. A.3 Chapter 2 A.3.1 Figure 2.1, p. 30 This is really a small detail. The caption of the bottom plot is \\(\\hat{E_{np}}(Y \\mid A= 1, H =1, T = 1)\\), s/b \\(\\hat{E}_{np}\\) A.4 Chapter 3 A.4.1 Typography: section 3.2 p. 40, equation 3.1 The current latex expression of conditional independence used seems to be (Y(0), Y(1)) \\ \\text{II} \\ T with the output \\[ (Y(0), Y(1)) \\ \\text{II} \\ T \\] a better typography would be \\perp\\!\\!\\!\\perp for the symbol \\(\\perp\\!\\!\\!\\perp\\). When used for equation 3.1 as (Y(0), Y(1)) \\perp\\!\\!\\!\\perp T we obtain \\[ (Y(0), Y(1)) \\perp\\!\\!\\!\\perp T \\] In the case when we want to show dependence, that is no independence then the latex expression is \\not\\!\\perp\\!\\!\\!\\perp for the symbol \\(\\not\\!\\perp\\!\\!\\!\\perp\\). For example equation 3.1 would become \\[ (Y(0), Y(1)) \\not\\!\\perp\\!\\!\\!\\perp T \\] A.5 Chapter 4 A.5.1 Section 4.1 p. 67 (on top) The line is which is statistically signficant should be significant A.6 Chapter 5 ## nothing found A.7 Chapter 6 A.7.1 Section 6.1 p. 100, first paragraph The second sentence says Mistakingly equation \\(E_H E(Y \\mid T=t \\mid H)\\) with [] Should it be \\(E_H (E(Y \\mid T=t) \\mid H)\\)? See extra \\()\\) before the last \\(\\mid\\). A.7.2 Section 6.3 p. 126, the script of simdr The last paragraph of p. 126 says We simulated \\(T\\) [] such that approximaly 600 individuals had \\(T=1\\) The simdr gives an incorrect result of 540 with the constant 0.13. That constant should be 0.15 to obtain 600. See the mathematical proof and proof by simulation in the appendix Doubly Robust Simulation at Analyse \\(T\\). A.8 Chapter 7 A.8.1 Section 7.2, equation (7.11), p. 139 \\(E(Y_1 \\mid A=1) - (E(Y_1\\mid A=0, Y_0=1) - E(Y_1\\mid A=0, Y_0=0)) - E(Y_0 \\mid A=0) - (E(Y_1\\mid A=0, Y_0=0) - E(Y_1\\mid A=0, Y_0=0))\\) A.8.2 Exercise 2 In the last paragraph of the exercise In addition, use exsim.r to simulate [] It should be ex2sim.r A.9 Chapter 8 A.9.1 Section 8.2, p. 150 The very first sentence of section 8.2 says [] the front-door theorm of Pearl [] It should be theorem "],["notes.html", "B Notes B.1 Chapter 2 B.2 Chapter 4 B.3 Chapter 6", " B Notes B.1 Chapter 2 B.1.1 section 2.4 p. 31 The second sentence of the last paragraph on p. 33 says We also need the car package in order for the summary() function to operate on boot objects the way we describe. This sentence is not required if we use the boot::boot.ci() which simplifies lmodboot.r() and does not require the car package. See the code in this document for lmodboot.r in chapter 2. B.2 Chapter 4 B.2.1 Section 4.1 See the plots in section 4.2. They could be helpful to visualize the changes in effect measures from one level of modifier to the other. B.2.2 Section 4.2 B.2.2.1 Monte Carlo Simulation A Monte Carlo is provided in section 4.2 and coded in a function called betasim_effect_measures(). It uses the \\(Beta\\) distribution. It is helpful in that it confirms the same results as in Jake Shannin (2021) is less CPU intensive as it needs only 5000 iterations to confirm Jake Shannin (2021) is easier to code than java and uses R which is the declared language of Brumback (2022) allows some extra flexibility with the shape parameters of \\(Beta\\) to investigate the conclusion with diffferent curves. See the suggestion for applications below. B.2.2.2 page 72, Figure 4.1 The probabilites shown in the Venn diagram do not add up to 100% because, for example, the event that RR changes in the same direction as RD but not in the same direction as the other two measures []. It would akward to arbitrarily one of those 2 chances as zero. Jake Shannin (2021) mentions that it is the result of not mutually exclusive events. That is true. Yet, these events, properly grouped are actually mutually exclusive. In section 4.2 they are called Opposite pairwise events. Using these definitions then yes, they are mutually exclusive but cannot be properly shown in the Venn diagram. This can be easily solved by splitting the probabilities. See section 4.2 for details. The end result a proper partitioning of the sample space \\(\\Omega\\) and is, in fact, a \\(\\sigma-field\\) (See Geoffrey R. Grimmet (2001), section 1.2). Yet it does not change the conclusions reached in Jake Shannin (2021). B.2.2.3 Applications See my sub-section 4.2 called Applications where 2 possible applications are mentioned. Data pre-processing (data cleaning) Bayesian prior for Beta-binomial model B.2.3 Exercises B.2.3.1 Exercise 1 Using the causal power, the conclusion is different than the official answer. It is not obvious why the official solution does not make use of the causal power. B.2.3.2 Exercise 5 The official solution uses gee with the default family, that is gaussian. Since the outcome \\(attend\\) is binary isnt it better to use the binomial family? We quote p. 50 from chapter 3 in that respect Because our outcome is binary, we choose to fit the logistic parametric model B.3 Chapter 6 B.3.1 Section 6.1.1 ATT The function bootstandatt is not necessary. The small change is taken care of in bootstand with the argument att. B.3.2 Section 6.3 The conclusions with the simulation are the same as Brumbacks. However her sd for the estimators \\(EY1exp\\) and \\(EY1dr\\) for both \\(ss=40\\) and \\(ss=100\\) dont agree with my results. They are so large that they raise questions. References "],["linreg.html", "C Linear Regression with R C.1 Model C.2 fitted() vs predict()", " C Linear Regression with R library(tidyr) library(dplyr) At about every turn in this book one needs to do a linear regression using R. It is a simple function, easy to use. Using it to translate the various mathematical expressions into values requires to learn its different flavors and what they mean in mathematical terms. It is one of those things we think we know well . . . until we actually have to use it. The goal of this appendix is to explain these subtleties in the context of Jake Shannin (2021). To illustrate we will use the stats::glm() function. Everything applies equally well to stats::lm(), gee::gee(), geepack::geeglm(), etc. C.1 Model We will use the model from Jake Shannin (2021). in chapter 5, section 5.2, on page 89. Its DAG is illustrated in figure 5.7. sim2 &lt;- function(n = 1000, seed = 888) { set.seed(seed) # Generate the observed confounder H &lt;- rbinom(n, size = 1, prob = 0.4) # Let the treatment depend on the confounder probA &lt;- H * 0.8 + (1 - H) * 0.3 A &lt;- rbinom(n, size = 1, probA) # Let the outcome depend on the treatment and the confounder probY &lt;- A * (H * 0.5 + (1 - H) * 0.7) + (1 - A) * (H * 0.3 + (1 - H) * 0.5) Y &lt;- rbinom(n, size = 1, prob = probY) data.frame(&quot;H&quot; = H, &quot;A&quot; = A, &quot;Y&quot; = Y) } df &lt;- sim2() str(df) ## &#39;data.frame&#39;: 1000 obs. of 3 variables: ## $ H: int 0 0 0 1 1 0 0 0 0 1 ... ## $ A: int 0 0 0 0 1 0 0 0 0 0 ... ## $ Y: int 1 0 0 0 0 1 1 0 1 1 ... C.2 fitted() vs predict() C.2.1 fitted() fitted() returns the expected values of the response after the link function is applied, i.e. \\(E(Y_I)\\). Also fitted() uses only the original data. For example n &lt;- 5 x &lt;- rnorm(n) y &lt;- rpois(n, lambda = exp(x)) df &lt;- data.frame(&quot;x&quot; = x, &quot;y&quot; = y) fit &lt;- glm(y ~ x, data = df, family = &quot;poisson&quot;) and fitted() give the \\(E(Y_i)\\) fitted.out &lt;- fitted(fit) fitted.out ## 1 2 3 4 5 ## 0.94168185 5.09080045 0.62860104 0.09141276 0.24750390 and if you try to fit with new data, nothing will happen, it doesnt use the new data returns the same output, no warning is given about the fact that newdata is not used. newdf &lt;- df newdf$x &lt;- rnorm(n, mean = 1, sd = 0.5) fitted(fit, newdata = newdf) ## 1 2 3 4 5 ## 0.94168185 5.09080045 0.62860104 0.09141276 0.24750390 C.2.2 predict() On the other hand predict gives the result before the link funciton is applied and uses newdata First lets use predict() with the existing data predict.out &lt;- predict(fit) predict.out ## 1 2 3 4 5 ## -0.0600878 1.6274351 -0.4642585 -2.3923702 -1.3963289 which is before the link function is applied and so exp(predict.out) == fitted.out ## 1 2 3 4 5 ## TRUE TRUE TRUE TRUE TRUE and there is an option, type = \"response\" that tells predict to applied the link function so you dont have to do it predict(fit, type = &quot;response&quot;) ## 1 2 3 4 5 ## 0.94168185 5.09080045 0.62860104 0.09141276 0.24750390 C.2.3 Conclusion In the context of Jake Shannin (2021) we use fitted() when we use the original data to get \\(E(E(Y_i))= \\hat{Y}\\) and predict()..., type = \"response) when we ave a counterfactual in the data, that is \\(E(E(Y_i \\mid T = t))= \\hat{Y} \\mid T=t\\) mean(fitted.out) ## [1] 1.4 References "],["mc_standdr.html", "D Doubly Robust Simulation D.1 Analyse \\(T = \\sum_{i=1}^J{T_i}\\) (Errata) D.2 Analyse \\(Y = \\sum_{i=1}^I Y_i\\) D.3 Functions D.4 Scripts", " D Doubly Robust Simulation D.1 Analyse \\(T = \\sum_{i=1}^J{T_i}\\) (Errata) Section 6.3 claims that \\(T=600\\) and \\(P(T=1 \\mid H) \\in [0.041, 0.0468]\\) but the results obtained from running simdr as shown in the book are different. Not a lot but enough to puzzle the avid reader (like me for example). So lets go through simdr to explain the differences. simdr.out &lt;- simdr(seed = 1009)$stats One might think that standardization with the exposure model would be preferable when the outcome indicates a rare condition. To see this, first suppose the condition is not rare. We might have 3000 individuals and 50%, or 1500, with the condition. Using the rule of thumb for logistic regression of Peduzzi et al. presented in chapter 2, we should be able to include 150 covariates in the outcome model. The Peduzzi rule can be found at the end of section 2.3, on top of p. 29. where it states that both the numbers of individuals with \\(Y=0\\) and \\(Y=1\\) need to be larger than ten times the number of parameters. and therefore Now suppose the exposure, \\(T\\), is divided more evenly: that is, we have 600 with \\(T=1\\). This would suggest we can include 60 covariates in the exposure model. Brumback uses a linear function of \\(H\\) to create a distribution of \\(T_i\\) that makes it dependent on \\(H\\) and which should give \\(\\sum T_i \\approx 600\\). However, the simulation with simdr returns \\(\\sum T_i \\approx 540\\). # sum of T simdr.out$`T`$sum ## [1] 541 We observe that \\(\\sum_i T_i \\approx 540 \\not \\approx 600\\). This is the part that needs explaining. The difference seems too large to be explained by the usual culprit, random process. To be able to do that lets use some notations and go through the mechanics of simdr. Let \\(H_{j}\\) be the covariate \\(j\\) \\[ \\begin{align*} H_j \\text{ i.i.d. } \\mathcal{Bernoulli}(p), \\, j = 1, \\ldots, J \\end{align*} \\] where \\(J\\) is the same variable as \\(ss\\) from Brumback, i.e. \\(J = ss = 100\\). Also \\(H_{i, j}\\) is the value of covariate \\(H_j\\) for individual \\(i\\). and let \\(T_i\\) be the treatment of individual \\(i\\) \\[ \\begin{align*} T_i \\sim \\mathcal{Bernoulli}(prob = P_i), \\, i = 1, \\ldots, I \\end{align*} \\] where \\(I\\) is set at \\(I=3000\\) by Brumback. In addition, we let \\[ S_i = \\sum_{j=1}^{J}H_{i, j} \\\\ \\text{where } J = ss \\text{ as mentioned above} \\] and simdr defines \\(P_i\\) as a random variable \\[ \\begin{align*} &amp;P_i = \\alpha \\frac{\\beta}{J} S_i + p \\times X_i \\\\ \\\\ &amp;\\text{where} \\\\ &amp;\\alpha = 0.13 \\\\ &amp;\\beta = 20 \\\\ &amp;p = 0.05 \\\\ &amp;X_i \\sim \\mathcal{Normal}(mean = 1, sd = 0.1) \\end{align*} \\] now, since \\[ \\begin{align*} H_i \\text{ i.i.d. } \\mathcal{Bernoulli}(p) &amp;\\implies E(H_i)=p \\\\ T_i \\sim \\mathcal{Bernoulli}(p_{i}) &amp;\\implies E(T_i) = E(P_i) \\\\ X_i \\sim \\mathcal{Normal}(mean = 1, sd = 0.1) &amp;\\implies E(X_i) = 1 \\end{align*} \\] and since \\(E()\\) is a linear function then \\[ \\begin{align*} E(T_i) &amp;= E(P_i) \\\\ &amp;= E(\\alpha \\cdot \\frac{\\beta}{J} S_i + p \\cdot X_i) \\\\ &amp;= \\alpha \\cdot \\frac{\\beta}{J} \\sum_{j=1}^{J}E(H_{i, j}) + p \\cdot E(X_i) \\\\ &amp;= \\alpha \\cdot \\frac{\\beta}{J} \\sum_{j=1}^{J}p + p \\cdot 1 \\\\ &amp;= \\alpha \\cdot \\frac{\\beta}{J} \\cdot J \\cdot p + p \\\\ &amp;= \\alpha \\cdot \\beta \\cdot p + p \\end{align*} \\] and the sum of the number of people treated is \\(T = \\sum_i^IT_i\\) \\[ \\begin{align*} E(T) &amp;= \\sum_{i=1}^I{E(T_i)} \\\\ &amp;= \\sum_{i=1}^I{(\\alpha \\cdot \\beta \\cdot p + p)} \\\\ &amp;= I (\\alpha \\cdot \\beta \\cdot p + p) \\\\ \\\\ &amp;\\text{and since} \\\\ &amp;I = 3000, \\, \\alpha = 0.13, \\, \\beta = 20, \\, p = 0.05 \\\\ \\\\ &amp;\\text{then} \\\\ E(T) &amp;= 3000 \\cdot (0.13 \\cdot 20 \\cdot 0.05 + 0.05) \\\\ &amp;= 540 \\end{align*} \\] which proves that the expected number of \\(T\\) is not really close to 600 but rather 540 which is also the result of the simulation. Therefore we could use 54 covariates rather than 60 by the Peduzzi rule. We note that this does not change the conclusions drawn from the simulation significantly. Finally, we note that the formula \\(\\alpha \\cdot \\beta \\cdot p + p\\) could be modified to get \\(T=600\\) by varying the coefficient \\(\\alpha=0.13\\) and/or \\(\\beta=20\\). If we change only \\(\\alpha\\) and keep \\(\\beta=20\\) we could use the result from above and with simple algebra \\[ \\begin{align*} E(T)&amp;= I (\\alpha \\cdot \\beta \\cdot p + p) \\\\ \\\\ &amp;\\text{and since we want } E(T) = 600 \\\\ &amp;\\text{and that} \\\\ &amp;\\beta = 20, \\, I = 3000, \\, p = 0.05 \\\\ \\\\ \\text{then} \\\\ 600 &amp;= 3000 \\cdot (\\alpha \\cdot 20 \\cdot 0.05 + 0.05) \\\\ \\alpha &amp;= \\frac{600 - 0.05 \\cdot 3000}{3000 \\cdot 20 \\cdot0.05} = \\frac{450}{3000} = 0.15 \\end{align*} \\] and we simulate using \\(\\alpha = 0.15\\) to validate simdr600.out &lt;- simdr(alpha = 0.15, seed = 1009)$stats simdr600.out$`T`$sum ## [1] 593 We suggest that simdr be modified to use 0.15 instead of 0.13. D.2 Analyse \\(Y = \\sum_{i=1}^I Y_i\\) First we analyse \\(Y = \\sum Y_i\\) mathematically using the same notation as above. \\[ \\begin{align*} &amp;\\text{as defined in simdr} \\\\ Y_i &amp;= 0.1 T_i + 0.1 \\frac{\\beta}{J} S_i \\\\ \\\\ &amp;\\text{therefore} \\\\ E(Y_i) &amp;=0.1 E(T_i) + 0.1 \\frac{\\beta}{J} E(S_i) \\\\ &amp;= 0.01 E(P_i) + 0.01 \\frac{\\beta}{J} \\sum_{j=1}^J{E(H_{ij})} \\\\ &amp;= 0.01 \\cdot(\\alpha \\cdot \\beta \\cdot p + p) + 0.01 \\sum_{j=1}^J{p} \\\\ &amp;= 0.01 \\cdot(\\alpha \\cdot \\beta \\cdot p + p) + 0.01 \\frac{\\beta}{J} \\cdot J \\cdot p\\\\ &amp;= 0.01 \\cdot(\\alpha \\cdot \\beta \\cdot p + p) + 0.01 \\cdot \\beta \\cdot p \\\\ \\\\ &amp;\\text{and given} \\\\ &amp;\\alpha = 0.13, \\, \\beta = 20, \\, p = 0.05 \\\\ \\\\ &amp;\\text{therefore} \\\\ E(Y_i) &amp;= 0.01 \\cdot(0.13 \\cdot 20 \\cdot 0.05 + 0.05) + 0.01 \\cdot 20 \\cdot 0.05 \\\\ &amp;=0.0013 + 0.0005 + 0.01 \\\\ &amp;= 0.0118 \\end{align*} \\] and since \\(Y = \\sum_{i=1}^I Y_i\\) then \\[ \\begin{align*} Y &amp;= \\sum_{i=1}^I Y_i \\\\ E(Y) &amp;= \\sum_{i=1}^I E(Y_i) = I \\cdot E(Y_i) \\\\ \\\\ &amp;\\text{and from above} \\\\ E(Y_i) &amp;= 0.0118 \\\\ \\\\ &amp;\\text{therefore} \\\\ E(Y) &amp;= I \\cdot E(Y_i) = 3000 \\cdot 0.0118 = 35.4 \\\\ &amp;\\approx 35 \\end{align*} \\] which mathematically proves the following We simulated \\(Y_i\\) as a function of \\(T_i\\) and \\(\\sum_{k=1}^{ss}H_{i,k}\\), such that approximately 35 individuals had \\(Y=1\\). and the result we get from both simdr is 38, close enough. simdr.out$Y$sum ## [1] 38 The mean of \\(\\sum_{k=1}^{ss}{H_{ik}}\\) was fixed at one, but when \\(ss\\) was set to 100, it ranged from 0.00 to 2.80. That is exactly what we get. c(&quot;min&quot; = simdr.out$sumH$min, &quot;max&quot; = simdr.out$sumH$max) ## min max ## 0.0 2.8 then \\(P(T = 1 \\mid H)\\) ranged from 0.041 to 0.468. The results are different. c(&quot;min&quot; = simdr.out$probT$min, &quot;max&quot; = simdr.out$probT$max) ## min max ## 0.03873516 0.41876534 Probably because the original simulation came up with \\(T=600\\) rather than \\(T=540\\) as discussed above. Indeed if we verify with the simulation with \\(T=600\\) the results are now reasonably close. c(&quot;min&quot; = simdr600.out$probT$min, &quot;max&quot; = simdr600.out$probT$max) ## min max ## 0.03873516 0.47476534 \\(E(Y \\mid T, H)\\) ranged from 0.000 to 0.036. and the results are almost identical c(&quot;min&quot; = simdr.out$probY$min, &quot;max&quot; = simdr.out$probY$max) ## min max ## 0.000 0.038 D.3 Functions The function simdr is found on p. 127-128. See the script in the last section of this appendix. We just added some arguments and and output to facilitate the analysis. See the next section Analysis. The Monte Carlo simulation is done with a non-parametric Monte Carlo function mc_standdr with the following script. See the section Simulation blow. Note that simdr was rewritten as function mc_standdr to facilitate the analysis of the algorithm perform a Monte Carlo simulation with the MonteCarlo package separate the data simulation from the measurement of estimates in 2 sub functions standdr_sim: Simulate the data standdr_est: Calculate the estimates using the simulated data from standdr_sim mc_standdr and simdr give exactly the same results for the simulatted data simdr.out &lt;- simdr(seed = 1009) new_simdr.out &lt;- standdr_sim(seed = 1009) stopifnot(identical(simdr.out$stats, new_simdr.out$stats)) as well as the measurements new_simdr.est &lt;- standdr_est(Y = new_simdr.out$data$Y, `T` = new_simdr.out$data$`T`, H = new_simdr.out$data$H) stopifnot(identical(simdr.out$est, new_simdr.est)) D.4 Scripts D.4.1 simdr #&#39; Doubly Robust Standardization Simulation #&#39; #&#39; Doubly robust standardization simulation. #&#39; #&#39; This is the function used in \\emph{Fundamentals of Causal Inference} by #&#39; B. Brumback in section 6.3 of chapter 6, p.127-128. \\code{standdr_stats} is #&#39; used in the output to give more statistics. Also the arguments #&#39; \\code{beta = 0.13} and \\code{gamma = 20} were necessary to analyse the #&#39; algorithm, they don&#39;t change anything. #&#39; #&#39; @param ss Number of covariates i.i.d with \\code{rbinom(n, size=1, prob=probH)} #&#39; @param alpha coefficient used to compute the distribution of \\code{`T`}. #&#39; @param beta coefficient used to compute the distribution of \\code{`T`}. #&#39; @param seed Seed used for random number generation, default is \\code{NULL}. #&#39; #&#39; @return List of statistics for thesimulated data and estimates using #&#39; different merhods. #&#39; #&#39; @examples #&#39; \\dontrun{ #&#39; simdr() #&#39; } #&#39; @export simdr &lt;- function(ss = 100, alpha = 0.13, beta = 20, seed = NULL) { set.seed(seed) # ss is the number of confounders # i.e. the number of columns of H H &lt;- matrix(0, 3000, ss) # Let all components of H be independent Bernoulli variables with p=0.05 probH &lt;- rep(0.05, 3000) for (i in 1:ss) { H[, i] &lt;- rbinom(n = 3000, size = 1, prob = probH) } # Let the treatment depend on a function of H sumH &lt;- apply(H, 1, sum) * beta / ss # make sure P(T=1) is between 0 and 1, i.e. positivity assumption probT &lt;- alpha * sumH + 0.05 * rnorm(n = 3000, mean = 1, sd = 0.1) # validate the positivity assumption stopifnot(probT &gt; 0, probT &lt; 1) `T` &lt;- rbinom(n = 3000, size = 1, prob = probT) # Generate the outcome depend on T and H probY &lt;- 0.01 * `T` + 0.01 * sumH # positivity assumption is not required for the outcome # see intro to chapter 6 p. 99 stopifnot(probY &gt;= 0, probY &lt;= 1) Y &lt;- rbinom(n = 3000, size = 1, prob = probY) # put the simulated resuts in a list stats &lt;- list(&quot;sumH&quot; = simdr_stats(sumH), &quot;probT&quot; = simdr_stats(probT), &quot;T&quot; = simdr_stats(`T`), &quot;probY&quot; = simdr_stats(probY), &quot;Y&quot; = simdr_stats(Y)) # fit the exposure model e &lt;- fitted(lm(`T` ~ H)) # refit the exposure model using an incorrect logistic model e2 &lt;- predict(glm(`T` ~ H, family = &quot;binomial&quot;), type = &quot;response&quot;) # compute the weights w0 &lt;- (1 - `T`) / (1 - e) w1 &lt;- `T` / e w02 &lt;- (1 - `T`) / (1 - e2) w12 &lt;- T / e2 # fit an overspecified (saturated) outcome model mod.out &lt;- lm(Y ~ `T` * H) # Estimate the expected potential outcomes using the various methods dat &lt;- data.frame(&quot;Y&quot; = Y, &quot;T&quot; = `T`) dat0 &lt;- dat dat0$`T` &lt;- 0 dat1 &lt;- dat dat1$`T` &lt;- 1 # the predicted data preds0 &lt;- predict(mod.out, newdata = dat0) preds1 &lt;- predict(mod.out, newdata = dat1) # calculate the estimates EYT0 &lt;- mean(Y * (1 - `T`)) EYT1 &lt;- mean(Y * `T`) EY0exp &lt;- weighted.mean(Y, w = w0) EY1exp &lt;- weighted.mean(Y, w = w1) EY0exp2 &lt;- weighted.mean(Y, w = w02) EY1exp2 &lt;- weighted.mean(Y, w = w12) EY0out &lt;- mean(preds0) EY1out &lt;- mean(preds1) EY0dr &lt;- mean(w0 * Y + preds0 * (`T` - e) / (1 - e)) EY1dr &lt;- mean(w1 * Y - preds1 * (`T` - e) / e) est &lt;- list( &quot;EYT0&quot; = EYT0, &quot;EYT1&quot; = EYT1, &quot;EY0exp&quot; = EY0exp, &quot;EY1exp&quot; = EY1exp, &quot;EY0exp2&quot; = EY0exp2, &quot;EY1exp2&quot; = EY1exp2, &quot;EY0out&quot; = EY0out, &quot;EY1out&quot; = EY1out, &quot;EY0dr&quot; = EY0dr, &quot;EY1dr&quot; = EY1dr ) list(&quot;stats&quot; = stats, &quot;est&quot; = est) } #&#39; Compute statistics from \\code{simdr}. Sames as \\code{standdr_est} #&#39; #&#39; @param x Vector of numeric values. #&#39; #&#39; @return list of statistics: \\code{sun(x), mean(x), min(x), max(x)}. #&#39; #&#39; @seealso standdr_stats #&#39; #&#39; @examples #&#39; simdr_stats(runif(20)) #&#39; @export simdr_stats &lt;- function(x) { list(&quot;sum&quot; = sum(x), &quot;mean&quot; = mean(x), &quot;min&quot; = min(x), &quot;max&quot; = max(x)) } D.4.2 mc_standdr #&#39; Monte Carlo Simulation of Doubly Robust Standardization #&#39; #&#39; @param ss Integer(). Number of covariates. #&#39; @param nrep Number of Monte Carlo repetitions. #&#39; @param width Width of interval. e.g. 0.95 will give interval c(0.025, 0.975). #&#39; Default is 0.95. #&#39; #&#39; @seealso standdr_sim standdr_est #&#39; #&#39; @return Dataframe of results. #&#39; @export mc_standdr &lt;- function(ss = c(40, 100), nrep = 1000, width = 0.95) { stopifnot(all(ss &gt;= 1), nrep &gt;= 1, width &gt; 0, width &lt; 1) # We use alpha = 0.15 to match results with the books ms_standdr_func &lt;- function(n = 3000, ss = 100, alpha = 0.13, beta = 20, probH = 0.05, seed = NULL) { # first we simulate the data dat &lt;- standdr_sim(n = n, ss = ss, alpha = alpha, beta = beta, probH = probH, seed = seed)$data # then output the estimates in a list standdr_est(Y = dat$Y, `T` = dat$`T`, H = dat$H) } params &lt;- list(&quot;ss&quot; = ss) mc.out &lt;- MonteCarlo::MonteCarlo(func = ms_standdr_func, nrep = nrep, param_list = params) # output results in a dataframe out &lt;- suppressWarnings(MonteCarlo::MakeFrame(mc.out)) out %&gt;% pivot_longer(cols = -ss, names_to = &quot;estimator&quot;, values_to = &quot;value&quot;) %&gt;% group_by(ss, estimator) %&gt;% summarize(n = n(), mean = mean(value), sd = sd(value), lower = quantile(value, probs = (1 - width) / 2), upper = quantile(value, probs = 1 - (1 - width) / 2)) %&gt;% ungroup() } #&#39; Data Simulation for Doubly Robust Standardization #&#39; #&#39; @param n Number of individuals/observations. #&#39; @param ss Number of covariates. #&#39; @param alpha coefficient used to compute the distribution of \\code{`T`}. #&#39; @param beta coefficient used to compute the distribution of \\code{`T`}. #&#39; @param probH probability of H. #&#39; @param seed Seed value. default is \\code{NULL}. #&#39; #&#39; @return List with a dataframe of Y, T and H and summary statitics. #&#39; @export #&#39; #&#39; @examples #&#39; \\dontrun{ #&#39; standdr_sim() #&#39; } standdr_sim &lt;- function(n = 3000, ss = 100, alpha = 0.13, beta = 20, probH = 0.05, seed = NULL) { set.seed(seed) # matrix of independent Bernoulli vector with prob = 0.05 # &quot;The columns of H were independent indicator variables each # with probability 0.05&quot; H &lt;- cbind(replicate(n = ss, rbinom(n = n, size = 1, prob = probH))) # let the treatment depend on a function of H # &quot;We simulated T as indicator variables with probabilities that varied as # a linear function of H such that approximately 600 individuals had T=1&quot; sumH &lt;- apply(H, MARGIN = 1, FUN = sum) * beta / ss probT &lt;- alpha * sumH + probH * rnorm(n = n, mean = 1, sd = 0.1) # validate the positivity assumption stopifnot(probT &gt; 0, probT &lt; 1) `T` &lt;- rbinom(n = n, size = 1, prob = probT) # generate the outcome depend on T and H # &quot;We simulated Y as a function T ans sumH such hat approximatey 35 # individuals had Y = 1&quot; probY &lt;- 0.01 * `T` + 0.01 * sumH # positivity assumption is not required for the outcome # see intro to chapter 6 p. 99 stopifnot(probY &gt;= 0, probY &lt;= 1) Y &lt;- rbinom(n = n, size = 1, prob = probY) # put the data in a data.frame df &lt;- data.frame(&quot;Y&quot; = Y, &quot;T&quot; = `T`, &quot;H&quot; = H) # output results in a list list( &quot;stats&quot; = list(&quot;sumH&quot; = standdr_stats(sumH), &quot;probT&quot; = standdr_stats(probT), &quot;T&quot; = standdr_stats(`T`), &quot;probY&quot; = standdr_stats(probY), &quot;Y&quot; = standdr_stats(Y)), &quot;data&quot; = list(&quot;Y&quot; = Y, &quot;T&quot; = `T`, &quot;H&quot; = H) ) } #&#39; Estimates from Doubly Robust Standardization Simulation #&#39; #&#39; @param Y Vector of outcomes #&#39; @param `T` Vector of treatments #&#39; @param H Matrix of covariates #&#39; #&#39; @return List of estimates #&#39; @export standdr_est &lt;- function(Y, `T`, H) { # fit the exposure model e &lt;- fitted(lm(`T` ~ H)) # refit the exposure model using an incorrect logistic model e2 &lt;- predict(glm(`T` ~ H, family = &quot;binomial&quot;), type = &quot;response&quot;) # compute the weights w0 &lt;- (1 - `T`) / (1 - e) w1 &lt;- `T` / e w02 &lt;- (1 - `T`) / (1 - e2) w12 &lt;- T / e2 # fit an overspecified (saturated) outcome model mod.out &lt;- lm(Y ~ `T` * H) # Estimate the expected potential outcomes using the various methods dat &lt;- data.frame(&quot;Y&quot; = Y, &quot;T&quot; = `T`) dat0 &lt;- dat dat0$`T` &lt;- 0 dat1 &lt;- dat dat1$`T` &lt;- 1 # the predicted data preds0 &lt;- predict(mod.out, newdata = dat0) preds1 &lt;- predict(mod.out, newdata = dat1) # calculate the estimates EYT0 &lt;- mean(Y * (1 - `T`)) EYT1 &lt;- mean(Y * `T`) EY0exp &lt;- weighted.mean(Y, w = w0) EY1exp &lt;- weighted.mean(Y, w = w1) EY0exp2 &lt;- weighted.mean(Y, w = w02) EY1exp2 &lt;- weighted.mean(Y, w = w12) EY0out &lt;- mean(preds0) EY1out &lt;- mean(preds1) EY0dr &lt;- mean(w0 * Y + preds0 * (`T` - e) / (1 - e)) EY1dr &lt;- mean(w1 * Y - preds1 * (`T` - e) / e) list(&quot;EYT0&quot; = EYT0, &quot;EYT1&quot; = EYT1, &quot;EY0exp&quot; = EY0exp, &quot;EY1exp&quot; = EY1exp, &quot;EY0exp2&quot; = EY0exp2, &quot;EY1exp2&quot; = EY1exp2, &quot;EY0out&quot; = EY0out, &quot;EY1out&quot; = EY1out, &quot;EY0dr&quot; = EY0dr, &quot;EY1dr&quot; = EY1dr) } #&#39; Compute Statistics from \\code{standdr_sim}. #&#39; #&#39; @param x Vector of numeric values. #&#39; #&#39; @return list of statistics: \\code{sun(x), mean(x), min(x), max(x)}. #&#39; #&#39; @examples #&#39; standdr_est(runif(20)) #&#39; @export standdr_stats &lt;- function(x) { list(&quot;sum&quot; = sum(x), &quot;mean&quot; = mean(x), &quot;min&quot; = min(x), &quot;max&quot; = max(x)) } "],["references.html", "References", " References "]]
